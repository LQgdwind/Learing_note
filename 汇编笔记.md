# 汇编笔记

**2023寒假简单学一点汇编知识**

## Chapter 1 主板和内存

### 主板

主板（Main Board，Mother Board，System Board）是微型机各种硬件的载体。微型机的CPU、内存及芯片组等部件都安装在一块电路板上，这块电路板称为主机板（主板）。

![image-20230102102419131](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230102102419131.png)



#### 主板结构

• AT、ATX和BTX三大类

• AT结构主要在早期的微型计算机中使用，目前已经被淘汰。AT结构的初始设计是让扩展总线以微处理器相同的时钟速率来运行。

• 扩展AT（Advanced Technology eXtended）主板结构，即ATX主板标准，取代了AT主板规格。

• BTX（Balanced Technology eXtended）是Intel公司2003年发布的新型主板架构，目标是取代ATX结构。新架构的发展目标是完全取消传统的串口、并口、PS/2等接口，并很好支持PCI Express和串行ATA等新技术。



#### 芯片组

• 芯片组（Chipset）是主板的核心组成部分

• 几乎决定了主板的全部功能

• 包括控制芯片组、主板BIOS芯片和CMOS芯片等





#### 控制芯片组

• 南北桥体系结构

• CPU+北桥+南桥的体系结构

• 内存控制器：北桥芯片

• I/O控制器：南桥芯片



#### 南北桥体系结构

![image-20230103084931553](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230103084931553.png)



**北桥芯片**

• 控制CPU、内存和图形加速器接口（AGP）等设备之间的数据传输

• 主板上靠近CPU插槽的位置。发热量一般较高，通常需要安装散热片

• 内存控制器中心（Memory Controller Hub，MCH）

• 前端总线FSB 由MCH提供，目前是64位

• 芯片组的名称就是以北桥芯片的名称来进行命名

• MCH芯片的类型决定着RAM的类型和容量

• 早期MCH提供的显卡接口是AGP（Accelerated Graphics Port）总线接口，但现在已被数据传输速率更快的PCI-E取代



**南桥芯片**

• I/O控制中心（I/O Controller Hub，ICH）

• 负责对I/O设备的读写控制和数据的传输处理，提供各种外部设备的接口来实现硬、软盘和光驱等设备之间的数据传输

• 一般在远离CPU插槽，靠近PCI槽的位置，这种布局是考虑到它所连接的I/O总线较多，离处理器远一点有利于布线

• IDE（Integrated Drive Electronics）控制器、USB（Universal Serial Bus）控制器、PCI控制器、音频控制器、SATA（Serial Advanced Technology Attachment）控制器和网络控制器、

DMA控制器、中断控制器、定时/计数器、实时时钟控制器RTC（Real-Time Clock）和CMOS RAM

• ICH10是最后一个版本→PCH平台控制器

• 支持6条PCI-E通道、4个主PCI接口、12个USB 2.0接口、并支持USB接口禁用功能，支持6个SATA 3Gbps接口



#### 单芯片组体系结构

• CPU+南桥的单芯片组体系结构

• 内存控制器、北桥芯片的其它部分包括GPU核心、PCI-E控制器等都被集成到CPU里面

![image-20230103092526668](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230103092526668.png)



#### BIOS及CMOS芯片

• BIOS（Basic Input/Output System，基本输入/输出系统）全称是ROM-BIOS，只读存储器基本输入输出系统

• 开机上电自检程序和系统启动自举程序、系统设置信息

• 早期的BIOS多为可重写EPROM芯片，现在多采用Flash ROM(可擦可编程只读存储器)

• CMOS芯片是电脑主板上的一块可读写的RAM芯片，用它来保存当前系统的硬件配置和用户对某些参数的设定。现在做到了BIOS芯片中

• CMOS电池



### 内存



#### 常用概念

**存储器容量**

• 存储器的容量以字节（byte）为单位，用大写字母B表示。

• 以字节编址，包含8个二进制位（bit）

• 二进制位用小写字母b表示。

• 在描述比较大的存储容量时，经常使用KB、MB、GB、TB等单位。



**内存地址及内容**

• 每个单元分配了一个唯一的地址，地址从0开始编号，顺序递增1



**字节、字、双字**

• 字节：字节是PC机中内存存取信息的基本单位，1个字节包含8个二进制位

• 字：1个字包含16个二进制位，即两个字节，分别称为高字节和低字节。

• 双字：1个双字包含32个二进制位



**存储器访问**

• 单字节数据访问

• 多字节数据访问

• 小端存储：低字节在前（Little Endian）的存储格式。即低地址中存放低字节数据，高地址中存放高字节数据

• 访问这些数据时只需给出最低单元的地址号



#### 单通道内存技术

• 单通道系统中，北桥芯片内部只有一个内存控制器，系统安装的多个内存条连接到同一个内存总线上。多个内存条相当于串行工作，一次只有一个内存条工作，内存条数目增多，只能增加容量，并不能增加带宽。

例子： 假定2条DDR 400内存条，工作在200MHz频率下，每个时钟可以传送2次64位数据，则单通道系统中内存总线的总带宽是多少？

200M×2×64÷8 = 6400MB/s = 3.2 GB/s



#### 双通道内存技术

• 芯片组有两个内存控制器，构成双通道内存总线（Dual Channel Memory Bus）

• 与内存本身无关，任何DDR内存都可工作在支持双通道技术的主板上

• 内存条利用并联方式运行，当连接两条内存时，总线宽度达到64×2=128位

• 双通道要求按主板上内存插槽的颜色成对使用，如双通道系统中安装两条2GB的内存比安装一条4GB的效果要好

例子：假定2条DDR 400内存条，工作在200MHz频率下，每个时钟可以

传送2次64位数据。双通道系统中内存总线的总带宽是多少？

 2×200M×2×64÷8 = 6400MB/s = 6.4GB/s



#### 三通道内存技术

• 随着Intel Core i7平台发布而出现，是双通道内存技术的后续技术发展

• 将同色的三根内存插槽插上内存即可，系统会自动识别，并进入三通道模式

• 如果插上非3或非6条的内存，如4根内存，系统会自动进入单通道模式。





### 接口与插槽

#### 主板插槽

• CPU插槽

• 接口方式有引脚式、卡式、触点式、针脚式

• 常见的CPU插槽类型可分为Slot架构和Socket架构两种

#### 内存插槽

• 早期的8位和16位SIMM(Single Inline Memory Module)内存模组使用30Pin接口

• 32位SIMM模组使用72Pin接口

• SDRAM开始使用DIMM结构的插槽

• SDRAM DIMM为168Pin DIMM结构，每面为84Pin，有两个卡口，

用来避免插入插槽时，错误将内存反向插入

• DDR DIMM则采用184Pin DIMM结构，每面有92Pin，只有一个卡口

• DDR2、DDR3 DIMM为240Pin DIMM结构，每面有120Pin

#### 电源插槽

• 有AT电源插座和ATX电源插座两种

• AT电源插座为12芯单列插座，目前已被淘汰

• ATX电源插座早期为D型20芯双列插座

• 从ATX 12V 2.0开始，电源接口从传统的20芯升级为24芯，多出的4芯主要是为解决功耗较大的PCI-E显卡供电问题

• CPU电源

• 4芯的+12V接插头，单独向处理器供电

• 服务器平台上由于对供电要求更高，很早引入了更强的8PIN 12V接口

#### PCI 插槽

• PCI（Peripheral Component Interconnect，外设部件互连总线）Intel公司1991年推出的用于定义局部总线的标准，支持即插即用

• 在CPU和原来的ISA总线之间插入的一级总线

• 工作频率一般为33MHz/66MHz，提供32位和64位两种位宽

• 33MHz下最大数据传输率为133MB/sec(32位)和266MB/sec(64位)

• 目前被PCI-E（PCI Express）逐步取代

#### PCI-E插槽

• 完全兼容PCI

• 较短的PCI-E卡可以插入较长的PCI-E插槽中使用，支持热拔插

#### IDE接口

• 也称作并行ATA（Parallel ATA）

• ICH有2个IDE通道，每个通道上可以连接2个IDE设备（如硬盘、光驱等），其中一个为主设备（Master），另一个为从设备（Master）

• 已经被SATA接口所取代

#### SATA

• Serial ATA

• 采用串行方式传输数据，只需要7芯电缆就能连接主板和硬盘。结构简单，支持热插拔，数据传输可靠性高，传输的速度达到600MB/s甚至更高

#### 机箱连接线

• 用来连接主板和机箱面板

• 计算机状态指示以及外延主板开关和接口

• 一般黑色/白色为负，其他颜色为正

#### 外部接口

• 主要包括用于操作控制、音视频输入/输出、网络接入、外置存储接入等接口

#### PS/2接口

• 来源于Personal 2，IBM个人电脑

• 用于鼠标、键盘等设备的输入装置接口，不是传输接口

• 只有采样率，没有传输速率

• 一般情况下，PS/2接口的鼠标为绿色，键盘为紫色

#### VGA、DVI和HDMI接口

• VGA是传输模拟信号，DVI和HDMI传输数字信号。后两者传输数字信号的抗干扰性和传输稳定性比VGA好。与DVI相比，HDMI主要优势是能够同时传输音频数据，在视频数据的传输上没有差别

#### USB接口

• 1996年Intel牵头推出

• 是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范

• 目前为3.0版本，传输速度达到4.8Gbps

• 已取代原有的串口和并口

#### e-SATA接口

• 扩展的SATA接口

• 让外部I/O接口使用SATA功能

• 并不是一种独立的外部接口技术标准

• 拥有e-SATA接口的电脑，可以把SATA设备直接从外部连接到系统当中，而不用打开机箱。

## Chapter 2 微处理器管理模式

### 微处理器基本结构

![image-20230104091007504](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104091007504.png)

#### CPU

‘• 中央处理部件（Central Process Unit，CPU）由指令部件和执行部件组成。指令部件包括指令预取单元（Instruction Prefetch Unit，IUP）和指令译码单元（Instruction Decode Unit，IDU）两部分。

• 指令预取负责从存储器取出指令，放到一个16字节的FIFO指令队列中，这个队列叫做指令预取队列。

• 指令译码单元从指令预取队列中取出指令，进行译码，并将译码后的可执行指令放入已译码指令队列中。

• 执行部件(Execution Unit，EU)执行从已译码指令队列中取出的指令。它包含8个32位通用寄存器、32位的算术运算单元ALU、1个64位的移位器和乘/除硬件。

• 如果是算术、逻辑或者移位指令，则交给ALU处理，若指令执行时需要段或者页单元产生操作数地址（寻址），则交给分段或者分页单元进行处理。

#### BIU

• 总线接口部件（Bus Interface Unit，BIU）通过数据总线、地址总线、控制总线来与外部环境联系，包括从存储器中预取指令、读写数据，从I/O端口读写数据，以及其他的控制功能。

• 数据总线和地址总线都是32位的。

• 从存储器中存储数据最快也需要两个时钟周期内完成。

#### MMU

存储器管理单元由分段部件和分页部件组成，提供存储器管理和保护服务，实现从逻辑地址到物理地址的转换，既支持段式存储管理、页式存储管理，也支持段页存储管理。



### CPU工作模式

![image-20230104091533208](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104091533208.png)

#### 实模式

• CPU被复位（加电）时，自动进入实模式。在实模式下，这些CPU就相当于高性能的8086，使用1MB地址空间以及16位的“段首址:偏移”的地址格式。

• 全部权限

#### 保护模式

• CPU支持内存分页机制，提供段式和页式内存管理功能，协助操作系统高效地实现虚拟内存，支持多任务和特权级等。

• 保护模式下CPU执行JMP/CALL/IRET等指令，就可实现任务切换。

• 分为特权级0、1、2、3

#### 虚拟8086模式

• 兼容以前的DOS及应用程序（即8086程序），从80386开始增加了虚拟8086模式（V86模式）

• 86模式是以任务形式在保护模式上执行的，每个任务都有自己的任务状态段，各个V86任务所拥有的1MB地址空间相互独立

• 特权指令，如屏蔽中断指令CLI、中断指令INT、中断返回指令IRET等，在DOS程序中是合法的。如果不让这些指令在V86模式中执行，DOS程序就无法工作。为了解决这个问题，V86管理程序采用模拟的方法来完成这些指令。

### 寄存器

• 微处理器内部的寄存器可以分为:

• 程序可见的寄存器（Program Visible Register）

• 程序不可见的寄存器（Program Invisible Register）

• 80386以上CPU才包含程序不可见寄存器组

#### 程序可见寄存器

• Intel 8086~Core2（包括64位扩展）

![image-20230104092437820](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104092437820.png)

#### 通用型寄存器

![image-20230104092510901](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104092510901.png)

• 通用寄存器功能中RAX，RBX，RCX和RDX可以作为64位，32位，16位和8位寄存器使用，微处理器访问不同长度数据时，可以直接利用表中的命名。

• 如利用MOV指令修改DX的值：MOV DX，0010h。指令给DX寄存器赋值0010h，指令执行结果只会改变寄存器低16位，RDX的其他部分保持不变。又如EAX的值为6BC30E9FH，那么，AX=0E9FH（AH=0EH，AL=9FH）。

#### 64位中新增（非扩展）寄存器

• R8~R15共8个64位寄存器。这些寄存器可以按照字节、字、双字或者四字方式寻址。

![image-20230104092630576](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104092630576.png)

#### 段寄存器

段寄存器

• 80286以前的CPU有4个段寄存器，分别称为代码段寄存器CS（Code Segment），数据段寄存器DS（Data Segment），堆栈段寄存器SS（Stack Segment），附加数据段寄存器ES（Extra Segment）。自80386 CPU开始，增加了FS和GS两个段寄存器。

• 分段：基于逻辑

• 分页：基于管理

• 实模式：段地址+段内偏移

• 保护模式：段选择符

• 这些段寄存器都是16位的，对于16位CPU段长度限制为2 16B=64KB，对于32位CPU段长度限制为2 32B=4GB，

• 实模式和V86模式下它们的用法兼容16位CPU，即段寄存器保存20位段首址的高16位，段首址的低4位为0。

• 在保护模式下，不直接存放段基址，而是存放一个索引，称之为段选择符（Segment Selector）。由段选择符从全局描述符表或局部描述符表中找到8个字节长的段描述符，从而确定关于这个段的全部描述信息。

• RPL（Requestor Privilege Level）：请求特权级，表示将要访问的段的特权级。取值范围为0～3。

• TI（Table Indicator）：表指示符。为0时，从全局描述符表（GDT）中选择描述符；为1时，从局部描述符表（LDT）中选择描述符。

![image-20230104093547153](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104093547153.png)

• Index：索引。指出要访问描述符在段描述符表中的顺序号，Index占13位。因此，顺序号的范围是0～8191。每个段描述符表（GDT或LDT）中最多有8192=213个描述符。

![image-20230104093658899](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104093658899.png)

例子：

DS=0023H

DS=0023H=0000 0000 0010 0011b，可知：Index=0 0000 0000 0100b=4。TI=0，RPL=11b=3。因为TI=0，DS的段描述符在GDT中。Index×8=4×8=0020H，该描述符在GDT表中的位置是0020H～0027H，占8个字节。RPL=3，请求特权级为3。

#### 专用寄存器

• Intel 8086~Core2专用型寄存器包括：指令指针寄存器、堆栈指针寄存器和标志寄存器等。

##### 指令指针寄存器IP/EIP/RIP

• 指令指针指向程序的下一条指令。

• 当微处理器为8086/8088，80286或者工作在实模式下时，这个寄存器取16位IP；80386以及更高型号的微处理工作于保护模式下时这个寄存器取32位EIP。在64位模式中，RIP包含40位地址总线。

• 指令指针可以由转移指令或者调用指令修改（间接）。

##### 堆栈指针寄存器SP/ESP/RSP

• 堆栈指针，指向栈顶单元。

这个寄存器作为16位寄存器时使用SP；

作为32位寄存器时，使用ESP；

64位使用RSP。

##### 标志寄存器FLAGS/EFLAGS /RFLAGS

• 用来指示微处理器状态并控制它的操作。

• 从8086开始直到Pentium微处理器向上兼容。

• 8086/8088和80286使用16位FLAGS寄存器。80386以及更高微处理器使用32位EFLAGS寄存器。64位版本中的RFLAGS包含EFLAGS和FLAGS寄存器

• 状态位+控制位

###### 进位标志CF（Carry Flag）

• 当结果的最高位（字节操作时的第7位或字操作时的第15位）产生一个进位或借位，CF＝1，否则CF＝0。

• 在移位或循环移位指令中，会把操作数的最高位（左移时）或最低位（右移时）移入CF中。

###### 奇偶标志PF（Parity Flag）

• Intel微处理器中采用奇校验，当执行结果的低8位中二进制1的个数为奇数时，PF为0，否则为1。

• 不考虑其他位

• 6DH+6DH=DAH

• DAH=1101 1010B，结果中有5个1，因此PF为0。

###### 辅助进位标志AF（Auxiliary Carry Flag）

• 在字节操作时若低半字节（一个字节的低4位）向高半字节有进位或借位；在字操作时若低位字节向高位字节有进位或借位，则AF＝1，否则AF＝0。

• 这个标志用于十进制算术运算指令中，即通过二进制数运算调整为十进制数表示的结果。(BCD）

• 零标志ZF（Zero Flag），当运算结果为零时，ZF为1；否则为0。

• 符号标志SF（Sign Flag），它与运算结果的最高位相同。对字节操作（

8位运算）来说，是结果的第7位；对字操作（16位运算）来说，是结果的第15位。当SF＝0时，结果为正数或0；当SF＝1时，结果为负数。

• 单步标志TF（Trap Enable Flag），当TF=1时，CPU进入单步方式，在每条指令执行以后产生一个内部中断（单步中断）。当TF＝0时，CPU执行指令后不产生单步中断。

• 中断允许标志IF（Interrupt Enable Flag），当IF=1时，允许CPU接收外部中断请求，此时为“开中断”状态。当IF=0时，屏蔽外部中断请求，此时为“关中断”状态。

• 方向标志DF（Direction Flag），在字符串操作指令中，当DF=0时，串操作为自动增址；当DF=1时，串操作为自动减址。STD指令置位DF，CLD指令清除DF。

• 溢出标志OF（Overflow Flag），带符号数运算时，当其运算结果超出了8位或16位带符号数所能表达的范围时，将产生溢出，置OF为1，否则OF清0。溢出OF与进位CF是两个不同性质的标志。

• IOPL（I/O Privilege Level），表示I/O特权级，IOPL占2位，取值为0、1、2、3对应四个特权级。只有特权级高于IOPL的程序才能够执行I/O指令，否则会产生异常，并将任务挂起。

• NT（Nest Task），嵌套任务位，此位只用于保护模式，如果保护模式下当前的任务嵌套在其他任务中，此位为1，否则为0。IRET指令会检测NT的值。若NT=0，则执行中断的正常返回；若NT＝1，则执行任务切换操作。

• VM（Virtual 8086 Mode），V86模式位。VM=1时，表示当前CPU正工作在V86模式下；VM=0，表示当前CPU工作在实模式或保护模式下。VM位只能在保护方式中由IRET指令置位（如果当前特权级为0）或在任意特权级上通过任务切换而置位。

###### 486以上新增标志位：ID、VIP，VIF和AC

• AC（Alignment Check），地址对齐检查位。寻址一个字或者双字时，当地址不在字或者双字的边界上，此时AC=1，否则AC=0。

• VIF（Virtual Interrupt Flag），虚拟中断标志，与VIP一起使用，在虚拟方式下提供中断允许标志位IF的副本。

• VIP（Virtual Interrupt Pending），虚拟中断挂起标志，为Pentium~Pentium 4处理器提供有关虚拟模式中断的信息，它用于多任务环境下，为操作系统提供虚拟中断标志和中断挂起信息。

• ID（Identification）微处理器标识标志，用来指示Pentium~Pentium 4处理器，支持CPUID指令。CPUID指令是Intel IA-32架构下获得CPU信息的汇编指令，可以得到CPU类型、型号、制造商、商标、序列号、缓存等一系列CPU相关的信息。

#### 控制寄存器

• CR0～CR3（Control Register）。

• CR0的低5位是系统控制标志，被称为机器状态字（Machine Status Word，MSW）

• 分页机制中用到CR3、CR2和CR0。

![image-20230104094317012](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104094317012.png)

• PE（Protection Mode Enable）：保护模式允许标志。PE=0为实模式，CPU复位时自动进入实模式；PE=1为保护模式。可以通过软件设置PE进入或退出保护模式。

• MP（Monitor Coprocessor Extension）：运算协处理器存在位，MP=1表示系统中有协处理器。

• EM（Emulate Processor Extension）：仿真位。设置该位可以使每条ESC指令引起7号中断（ESCape指令用来对80387协处理器指令编码）。EM=1时，可以利用7号中断，用软件来仿真协处理器的功能；EM=0时用硬件控制浮点指令。• TS（Task Switched）：任务切换标志。TS=1时表明任务已经切换，在保护模式下，TR的内容改变将自动设置此位为1。

• ET（Extension Type）：协处理器选择标志，早期80386里面没有80387协处理器，因此设置此位。当处理器复位时，ET位被初始化以指示系统中数字协处理器的类型。如果系统中存在 80387协处理器，那么ET位置1；如果系统中存在80287协处理器或者不存在协处理器，那么ET位清0。80386以后的系统中ET位被置为1表示系统中存在协处理器。

• PG（Paging Enable）：分页标志。PG=1时，存储器管理单元允许分页，线性地址通过页表转换获得物理地址。PG=0时，分页功能被关闭，线性地址等于物理地址。当PG=0时，CR2和CR3寄存器无效，PG=1时二者用于分页管理机制。

##### 分页-页面

• 每页大小为4KB。CR3也被称做页目录基址寄存器PDBR（Page Directory Base Register），它的高20位用于保存页目录表的起始物理地址的高20位。

• 向CR3中装入一个新值时，低12位必须为0，这是由于页目录是页对齐的，所以仅高20位有效，低12位保留未用；从CR3中取值时，低12位被忽略。

• CR2也被称做页面故障线性地址寄存器（Page Fault Linear Address Register），用于发生页异常时报告出错信息。如在访问某个线性地址时，该地址的所在页没有在内存中，则发生页异常，处理器把引起页异常的线性地址保存在CR2中。

#### 全局描述符表寄存器

• 全局描述符表（Global Descriptor Table，GDT）是用来定义全局存储器空间的一种机制，它用段描述符来描述一个全局存储器中的段，每个GDT最多含有2 <sup>13</sup>=8192个描述符（8192×8=64KB）。

• 全局描述符表可以存储在内存的任何位置，通过全局描述符表寄存器（Global Descriptor Table Register，GDTR）给出它的位置和大小。LGDT指令可以将描述符表的起始位置装入GDTR。

• GDTR是48位的寄存器。其最低16位是限长，给出GDT的字节大小（其值比GDT的长度少1），其高32位是基址，指出GDT在物理存储器中存放的基地址。



例子：已知GDTR=0E003F0003FFH，则全局描述符表的基址是多少？这个全局描述符表有多大，里面有多少个描述符？

• GDT的地址为0E003F00H

• 长度为3FFH+1=400H。

• 可容纳400H/8=80H个段描述符。

#### 中断描述符表寄存器

• 中断描述符表寄存器（Interrupt Descriptor Table Register，IDTR）也在存储器中定义了一个表，该表称为中断描述符表IDT。

• IDT中保存的不是段描述符，而是中断门描述符。每个门描述符也包含8字节

• IDT最多包含256个门描述符，因为CPU最多支持256个中断。中断门指向的是中断服务程序的入口。

• IDTR是48位的寄存器。其最低16位是限长，给出IDT的字节大小（其值比IDT的长度少1），其高32位是线性地址，经过分页部件转换为物理地址，指出IDT在物理存储器中存放的基地址。

• 保护模式下的中断描述符表IDT的位置是可变的，实模式下的中断向量表的地址是固定在物理地址00000H处。

• GDTR和IDTR的值必须在进入保护模式之前装入。在实模式下执行LGDT和LIDT指令装入GDTR和IDTR。



例子：

已知IDTR=0E003F40007FFH，则中断描述符表的基址是多少？这个中断描述符表有多大，里面有多少个描述符？

• IDT的地址为0E003F400H

• 长度为7FFH+1=800H

• 可容纳800H/8=100H个描述符。

#### 局部描述符表寄存器

• 保护模式提供了多任务的环境，为每个任务建一个局部描述符表（Local Descriptor Table，LDT）。

• LDT只含有与系统中某一个任务相关的各个段的描述符。

• 可以使每一任务的代码段、数据段、堆栈段与系统其他部分隔离开。

![image-20230104100121846](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104100121846.png)

• ①和②步由GDTR确定了GDT表在存储器中的位置和限长。LDTR中是一个选择符，它包含了LDT描述符在GDT中的索引。③步是依据LDTR在GDT中取出LDT描述符的过程。在LDT描述符中，包含由LDT的位置和限长，即④和⑤步

#### 任务寄存器

• 任务寄存器（Task Register，TR）在保护模式的任务切换机制中使用。TR是16位的选择符，其内容为索引值，它选中的是TSS描述符。TR的初值由软件装入，当执行任务切换指令时TR的内容自动修改。

• 在多任务环境下，每个任务都有属于自己的任务状态段（Task Status Segment，TSS），TSS中包含启动任务所必需的信息。

• 任务状态段TSS在存储器的基地址和限长（大小）由TSS描述符指出。TSS描述符放在全局描述符表GDT中，TR内容为选择符，它指出了TSS描述符在GDT中的顺序号。

![image-20230104100359454](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104100359454.png)

• ①和②步由GDTR确定了GDT表在存储器中的位置和限长。TR是一个选择符，这个选择符中包含了TSS描述符在GDT中的索引。③步依据TR在GDT中取出TSS描述符。在第④和⑤步中，在TSS描述符中取得TSS的基址和限长。



例子：

假定全局描述符表的基址为00011000H，TR为2108H，问TSS描述符的起止范围是多少？

• TSS起始地址=00011000H+2108H=00013108H

• TSS终止位置=00013108H+7H=0001310FH



### 内存管理

• 实模式下分段管理

• 20位地址总线，最大可寻址内存空间应为2 20=1MB，其物理地址范围从00000H～FFFFFH。

• 段的大小可以变化，16位CPU中最大的段为2 16=64KB。段的起始地址可以在任何16的倍数上，段寄存器中存放段基址除以16得到的商（也就是20位段基址的高16位）。

• 段基址:偏移量

• 10H×段基址+偏移量



![image-20230104101131812](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104101131812.png)

例子：

• 计算实模式下1000:1F00、11F0:0000、1080:1700的物理地址。

• 1000:1F00=10H×1000+1F00=11F00H；

• 11F0:0000=10H×11F0+0000=11F00H；

• 1080:1700=10H×1080+1700=11F00H。

#### 保护模式下分段管理

• 保护模式下，逻辑地址同样由段基址:偏移量的格式形成，只不过，原来用来存储段基址的段寄存器不再表示段的起始位置，而是用来表示段选择符。

• 该地址表示形式称为虚拟地址，对应的地址空间称为虚拟地址空间。

• 以CS:EIP为例， CS中存放了一个16位的段选择符，EIP是32位偏移量。16位段选择符加上32位偏移量，总共是48位，其中段选择符的2位RPL与虚拟地址的转换无关，因此可以认为虚拟地址是46位的，段选择符的Index和TI占14位，偏移量为32位，虚拟地址空间为2<sup>46</sup>B=64TB

![image-20230104130256342](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104130256342.png)

#### 段描述符

• 段描述符用于描述代码段、数据段和堆栈段。

• 段描述符位于GDT或LDT中，占8字节（64位），包括：段基址（32位）、限长（20位）、访问权限（8位）和属性（4位）。

![image-20230104131528752](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104131528752.png)

![image-20230104131612348](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104131612348.png)

• P（Present）：存在位。P＝1时表示该段己装入内存；P＝0时表示该段没有在内存中，此时访问该段会产生段异常。操作系统将某个段从物理内存中交换到磁盘时，设置此位为0。

• DPL（Descriptor Privilege Level）：描述符特权级，说明该段的特权级，取值为0～3。

• S（System）：描述符类型位，S=1时，这个段为代码段、数据段或堆栈段；S=0时，为系统段描述符。

• E（Executable）：可执行位，用来区分代码段和数据段。S=1且E=1时，这是一个代码段，可执行。S=1且E=0时，这是一个数据段或堆栈段，不可执行。E=0时，后面的两位为ED和W；若E=1时，后面的两位为C和R。• ED（Expansion Direction）：扩展方向位（对数据段或堆栈段）。ED=0时，段向上扩展（从低地址向高地址扩展），偏移量小于等于限长。ED=1时，段向下扩展（从高地址向低地址扩展），偏移量必须大于限长。限长是指地址上限。一般情况下ED位为0。

• W（Writeable）：写允许位（对数据段或堆栈段）。W=0时，不允许对这个数据段写入；W=1时，允许对这个数据段写入。

• C（Conforming）：一致位（对代码段）。C=0时，这个段不是一致代码段；C=1时，这个段是一致代码段。一致代码段就是操作系统拿出来被共享的代码段，这些代码段允许被低特权级的用户直接调用访问。

• 此时特权级高的程序不允许访问特权级低的代码，即核心态不允许调用用户态的代码；特权级低的程序可以访问到特权级高的代码，但是特权级不会改变。

• 除了一致代码段外，其他的代码段称为非一致代码段。非一致代码段常用于那些为了避免低特权级的访问而被操作系统保护起来的系统代码。非一致代码段只允许特权级相同的程序间访问，绝对禁止不同级访问，即核心态不使用用户态，用户态也不使用核心态。

• R（Readable）：读允许位（对代码段）。R=0时，不允许读这个段的内容；R=1时，允许读这个段的内容。对代码段进行写操作总是被禁止的。

• A（Accessed）：访问位。A＝1表示段己被访问（使用）过；A＝0表示段未被访问过。操作系统利用这个位对段进行使用统计，可以将那些很长时间没有被访问过的段从内存中调出，释放其内存给其他程序所使用。

• G（Granularity）：粒度。G＝1时，限长以页为单位；G＝0时，限长以字节为单位。

• D（Default Operation Size）：默认操作数宽度。D＝1时，为32位数据操作段；D＝0时，为16位数据操作段。• 限长位在描述符中一共占2位。G＝1时，限长的内容加上1后就是段所占的页数，1页的大小为2<sup>12</sup>＝4KB；G＝0时，段限长以字节为单位，限长的内容+1就是段所占的字节数。

• G＝1，限长位为FFFFFH时，段所占的页数是FFFFFH+1=100000H，即2<sup>20</sup>页，段的大小为2<sup>32</sup>=4GB，有效偏移量的范围是00000000H～FFFFFFFFH。G＝0，限长位为FFFFFH时，段的大小为2<sup>20</sup>=1MB，有效偏移量的范围是00000000H～000FFFFFH。



例子：设段基址为0CD310000H，段界限为001FFH。G位分别为0和为1时，求段的起始地址和段的结束地址。

• 段的起始地址=段基址=0CD310000H

• （G=0）段的结束地址=段基址+段限长=0CD310000H+001FFH=0CD3101FFH

• （G=1）段的结束地址=段基址+段限长=0CD310000H+(001FFH+1)×4K−1=0CD50FFFFH

#### 段描述符高速缓存

• 如果每一次都需要到内存中去读取段描述符，那么CPU的运行效率就会极大地降低。为解决这个问题，CPU在内部设置了段描述符高速缓存。段描述符高速缓存总是与CS、DS、ES、SS、FS、GS段寄存器和描述符的当前值保持一致，只有段寄存器的值发生改变时，才需要到GDT或LDT中装入段描述符。

• 这些缓存器是不可见的

#### 段式地址转换

![image-20230104131930282](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104131930282.png)

#### 页式内存管理

• 每一个任务都有它自己的一个线性地址空间，由于线性地址是32位的，所以线性地址空间为2 32=4GB。分段管理时，段的长度不固定，段和段之间也允许重叠；而页面的划分则严格得多。所有页的长度固定，页与页之间也没有重叠。

• 页面大小为4KB，则32位CPU将4GB的线性地址空间划分成2<sup>20</sup>页。

• 分页机制就是一种将线性地址的页面映射到物理地址页面的手段，也就是从线性地址到物理地址的转换过程。分页机制中用到了两个表：页目录表和页表。

• 32位线性地址被划分为3个部分：页目录索引（10位），页表索引（10位），页面字节索引（12位），其中第1项是对页目录（Page Directory）的索引，第2项是对页表（Page Tables）的索引，第3项是线性地址在页面（Page Frame）内的偏移。

![image-20230104132027204](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104132027204.png)

![image-20230104134309930](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104134309930.png)

• ①：页目录的地址由CR3的最高20位决定，CR3又被称做页目录基址寄存器PDBR（Page Directory Base Register），CR3的低12位＝000H。页目录的大小为4KB，由1024个页表描述符组成，每个页表描述符占4个字节。

• ②：线性地址中高10位为页目录索引，页目录基地址加上页目录索引乘以4获得的地址指向页目录表中一个页表描述符。

• ③：页表描述符的高20位给出了页表的基地址。页表同样占4KB，由1024个页描述符组成，每个页描述符占4字节。• ④：线性地址中的页表索引（10位），指示了被访问的页在页表中的序号。根据页表基地址加上10位页表索引乘以4指向页表中的一个页描述符。

• ⑤：页描述符的高20位给出了物理页面的基地址的高位20位。

• ⑥：物理页面的基地址再加上线性地址中12位字节的页内偏移量，得到物理地址。

• 片内转换检测缓冲器（32个页描述符）

#### 页表项

• 页目录表、页表和页面的基地址的低12位全部为0，定位在页的边界上。

• 页表项的低12位提供保护功能和统计信息。U/S位、R/W位、P位实现页保护机制；D位和A位提供统计信息。

![image-20230104135716846](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104135716846.png)

• U/S（User/Supervisor）：用户/管理员位。U/S=0时，只有操作系程序可以访问该页，不允许用户程序访问，这可以保护操作系统使用的页面不被用户程序破坏（读写）；U/S=1时，允许用户程序访问该页。

• R/W（Read/Write）：读写位。R/W＝0，用户程序对页面只有读限，不能写入；R/W＝1时，可读/写。不论R/W位设置如何，操作系统的程序都可以对页面进行读写。

• P（Present）：存在位。P=1，页表或页存在于物理内存中；P=0，页表或页不在物理内存中。如果内存不足时，操作系统会选择那些使用频率低的页面，设置它们的P位为0，将这些物理页面释放出来供其他程序使用。产生缺页异常时，程序中使用的32位线性地址被保存在CR2中。

• A（Accessed）：访问标志。如果对某页表或页访问过，CPU设置页表项中的A位为1。操作系统定期扫描该项，统计使用次数。当需要调出（释放）页面时，操作系统一般选择那些最少使用的或长期不用的页。

• D（Dirty）：写入位。D=1时表示对该页进行过写操作，D=0时表示对该页还没有进行过写操作。D位只用于页描述符，它是写入标志。当需要释放某个物理页面时，若其D=0表示磁盘中交换页面的内容和物理页面的内容一致，不需要向磁盘重写；若D=1则需要将这个页面写到磁盘

![image-20230104135816485](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104135816485.png)

• 一个物理页存在两级保护属性，一个是页表描述符中的保护属性，另一个是页描述符中的保护属性。在两级保护属性不一致的情况下，CPU从二者中取一个较严格的保护权限。例如，页表描述符的属性R/W＝0（只读），页描述符的属性R/W＝1（可读写），则最后结果是R/W＝0（只读）。

![image-20230104143312508](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104143312508.png)

![image-20230104143452809](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104143452809.png)

### 任务

• 在保护模式下每个任务是独立的，CPU提供了实现任务间快速切换的高效机制。在任何时刻都有一个当前任务，由TR寄存器指定，CPU在这个任务的环境下执行。当运行一个应用程序后，操作系统就为这个程序创建一个任务。

• 每个任务都由两个部分组成：任务执行环境（Task ExecutationSpace）和任务状态段TSS（Task State Segment）。

#### 任务执行环境

• 任务执行环境包括一个代码段、堆栈段和数据段等，任务在每一个特权级上执行时都有一个堆栈段。

• 每个任务都有一个LDT描述符表，构成一个局部地址空间，局部空间的数据和代码不能被其他任务访问。

![image-20230104145231709](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104145231709.png)

#### 任务状态段

• 任务状态段TSS（Task State Segment）中保存了任务的各种状态信息。它在任务切换过程中起着重要作用，通过它可以实现任务的挂起和恢复。

• 在任务切换过程中，首先CPU中各寄存器的当前值被自动保存到TR所指定的TSS（当前任务状态段）中；然后下一任务的TSS的选择符被装入TR；最后从TR所指定的TSS中取出各寄存器的值送到处理器的各寄存器中。

• 任务状态段在主存中的位置、大小和属性等信息由任务状态段描述符（即TSS描述符）来描述。TSS描述符属于系统描述符，S位等于0，它必须放在GDT表中，而不能放在LDT或IDT中。

• 在任务切换或执行LTR指令时，会将新的任务状态段选择符装载到TR寄存器。

![image-20230104145324907](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104145324907.png)

• TSS的基本格式由104字节（000H～067H）组成。这104字节的基本格式是不可改变的，在此之外系统软件还可在TSS段中定义若干附加信息。基本的104字节可分为寄存器保存区域、内层堆栈指针区域、地址映射寄存器区域、域链接字段区域、I/O许可位图等。

• LDTR和CR3的值与特定任务相关，随着任务的切换，LDTR和CR3的值也要切换。TSS中保存了该任务的CR3和LDTR。

• 链接字段位于在TSS偏移0开始的双字中，其高16位未用，而低16位保存前一任务的TSS的选择符。如果当前的任务由段间调用指令CALL、中断/异常而激活，那么当前任务TSS中的链接字段保存被挂起任务的TSS的选择符，并且标志寄存器EFLAGS中的NT位被置为1，表示嵌套。

• I/O许可位图区域是为了实现输入/输出的保护。I/O许可位图作为TSS的扩展部分，TSS内偏移66H处的字用于存放I/O许可位图在TSS内的偏移（从TSS的头开始计算）。

### 门

• 4种：调用门、任务门、中断门、陷阱门

• 调用门用于控制传送，来改变任务或者程序的特权级别；任务门像个开关一样，用来执行任务切换；中断门和陷阱门用来指出中断服务程序的入口地址。

• 门描述符属于系统描述符

#### 门描述符

![image-20230104145554410](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104145554410.png)

• 系统描述符中设置了一个类型（TYPE）字段，4位可表示16种类型 

![image-20230104145622066](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104145622066.png)

#### 调用门

• 调用门可以实现当前任务从低特权级到更高特权级的间接控制转移，它在更高级特权级的段中定义了一个入口点，该入口点的虚拟地址（目标选择符和偏移量）包含在调用门中。

• 调用门可以驻留在GDT中，也可以驻留在LDT中，但是不可在IDT中。

• 参数计数值表示有多少个（最多31个）参数必须从主程序（低特权级代码段）的堆栈复制到被调用子程序（高特权级代码段）的堆栈。将它乘以4后（32位系统）或者乘2（16位系统），得到参数在堆栈中的字节数。其他门描述符的参数计数值无意义。



**使用调用门进行段间调用操作过程**

![image-20230104145704901](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104145704901.png)

• 调用指令“CALL X:Y”指令中虚拟地址X:Y，其中X是一个选择符，由它指向了一个调用门描述符（第①步），而Y的值不起作用。

• 调用门描述符中的选择符指向了一个段描述符（第②步），段描述符指出了被调用段的段基址（第③步），而入口点的偏移量就是门描述符中的偏移量（第④步），决定了调用哪一个代码段以及子程序在代码段中的偏移。

• 这种形式的CALL指令可以通过调用门转移到更高的特权级，在更高的特权级下执行所调用的子程序，子程序执行完毕后，由RET指令返回CALL指令所在的较低级别的程序。

#### 任务门

• 任务门内的选择符必须指示GDT中的任务状态段TSS描述符，门中的偏移量无意义。任务的入口点保存在TSS中。利用段间转移指令JMP和段间调用指令CALL，通过任务门可实现任务切换。

![image-20230104145754719](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104145754719.png)

#### 中断门和陷阱门

• 中断门和陷阱门描述中断/异常处理程序的入口点

• 中断门和陷阱门内的选择符必须指向代码段描述符，门内的偏移就是对应代码段的入口点的偏移。

• 中断门和陷阱门只有在中断描述符表IDT中才有效。

### 任务切换

#### 任务切换的场景

• 当前的程序、任务、过程执行远程JMP或者CALL指令，选择了GDT中的TSS描述符，此时指令中的偏移量忽略。

• 当前的程序、任务、过程执行远程JMP或者CALL指令，从GDT或者LDT中选择了任务门，目标地址的偏移量部分被忽略，新的TSS选择符在门中。

• 发生了中断或异常，中断向量选择了IDT中的任务门。新TSS选择符在门中。

• 当FLAGS中的NT=1时，执行IRET指令，目的任务选择符在执行IRET任务的TSS链接域中。

#### 直接任务切换

![image-20230104152636315](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104152636315.png)

#### 间接任务切换

• 间接任务切换通过任务门来完成。利用段间转移指令JMP和段间调用指令CALL，通过任务门可实现任务切换。

• 任务的入口点保存在TSS中。

![image-20230104152652506](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104152652506.png)

• 间接任务切换时，指令中的段寄存器内容为任务门描述符。

• 当使用JMP/CALL X:Y指令时，由X指向一个任务门描述符去查找GDT或者LDT；为中断响应时查找IDT，获得任务门。取出任务门中的TSS选择符，去GDT中查找获得新TSS描述符。注意新TSS的B位必须为0。

• JMP或CALL指令内的偏移（Y）没有被使用。

• 任务门的DPL（DPLGATE）规定了访问该任务门的最低特权级，只有在同级或更高级别的程序中才可以访问它。即DPLGATE≥MAX（CPL，RPL），RPL是任务门选择符X的最后2位。

#### 任务切换步骤

• ①特权级检查；

• ②是否存在内存和限长检查；

• ③更新TR，并保存旧的TSS动态部分；

• ④加载TR，使新任务B=1，加载任务中各种寄存器内容。当CR0中TS被置位时表示任务切换完毕。

#### 任务内特权级变化时堆栈指针的使用

• 通过调用门向高特权级转移

• 只有在特权级变化时，才会切换堆栈。

• TSS中包含有指向0级、1级和2级堆栈的指针。（为什么？）

• 还有SS和ESP

• 在特权级提升时，根据新的特权级使用TSS中相应的堆栈指针对SS及ESP寄存器进行初始化，建立起一个空栈。再把低特权级程序的SS及ESP寄存器的值压入堆栈，以使得相应的返回指令可恢复原来的堆栈。（为什么？）

• 原特权级无法直接获取• 从低特权级堆栈复制以双字为单位的调用参数到高特权级堆栈中，调用门中的CNT字段值决定了参数的个数。

• 通过复制栈中的参数，使高特权级的子程序可以访问主程序传递过来的参数。

• 与使用CALL指令通过调用门向高特权级转移相反，使用RET指令实现向低特权级转移。段间返回指令RETF从堆栈中弹出返回地址。

• 段间返回指令RETF从堆栈中弹出返回地址（CS:EIP）。选择符的RPL确定返回后的特权级。

• RET指令所使用的返回地址的选择符只能是代码段描述符，而不能是系统描述符或门描述符。与CALL指令不能向低特权级转移相对应，RET指令不能向高特权级转移。

### 保护

• 对数据的保护

• 对程序的保护

• 对输入输出的保护

#### 数据访问保护

• 类型检查。装入CS时，段描述符中的E位必须为1，标记为可执行的段；装入DS、SS等寄存器时，E位必须为0。数据段描述符的W位为0时，不能对数据段进行写操作。代码段描述符的R位为0时，不能对代码段进行读操作。

• 限长检查

• 其他属性检查。主要是P位（存在位）

#### 特权级检查

• DPL≥MAX（CPL，RPL），即程序只能访问特权级相同或者较低的数据

![image-20230104153205812](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104153205812.png)

• 给SS赋值时，除了要满足DPL≥MAX（CPL，RPL）的条件之外，还必须满足RPL=CPL。也就是说SS的RPL总是等于当前执行程序的CPL。

#### 转移

##### 直接转移

不涉及门，段内或者段间直接取得段描述符。



段内转移

• 在同一代码段内转移时，显然转移前后不重新加载CS，特权级不发生变化，使用普通的跳转（JMP）或调用（CALL）指令即可。这时只需要检查限长



段间转移

• 需使用远跳转或远调用指令，指令的格式如：“JMP X:Y”、“CALL X:Y”等，其中X是16位段选择符，Y是32位偏移。此时需要重新加载CS寄存器，处理器除了要检查限长以外，还要执行特权检查。

![image-20230104153349601](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104153349601.png)



##### 间接转移

• 当CPL＞DPLTSS时，就不能采用直接切换，必须通过任务门进行任务切换。

• 选择符指向的是任务门描述符，门中的TSS选择符选中新任务的TSS描述符，启动新的任务。



涉及到的特权级

• 当前特权级CPL，即JMP或CALL指令所在的程序的特权级

• 请求特权级RPL，即选择符X的最低2位

• DPLGATE，即门描述符的DPL

• DPLCODE，即目标代码段描述符的DPL

• CCODE，即目标代码段描述符的C位



**间接转移条件-使用CALL指令**

• DPLGATE≥MAX（CPL，RPL）

• DPLCODE≤CPL

• 在满足前面两条特权级要求的情况下：

• 如果CCODE为1，表示一致代码段，则当前特权级不变；

• 如果CCODE为0，则当前特权级提升为DPLCODE（DPLCODE＜CPL或者维持不变（DPLCODE＝CPL）。

![image-20230104153455466](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104153455466.png)



**间接转移条件-使用JMP指令**

• DPLGATE≥MAX（CPL，RPL）

• CCODE为1且DPLCODE≤CPL 或 CCODE为0且DPLCODE＝CPL

• JMP指令只能转移到同级的代码，而不能转移到更高的特权级。



#### 输入输出保护

• CPU采用I/O特权级IOPL（I/O Privilege Level）和TSS段中I/O许可位图的方法来控制输入/输出，实现对应用程序I/O指令的限制。

• CPL≤IOPL时，可以执行I/O敏感指令。

• 任务状态段中的I/O许可位图也影响I/O敏感指令的执行。I/O许可位图规定了I/O空间中的哪些地址可以由该任务的任何特权级程序所访问，而不受IOPL的限制。

![image-20230104153544339](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104153544339.png)

• 当前特权级CPL比IOPL高或者相同时，可以正常执行所有I/O敏感指令；

• CPL特权级比IOPL特权级低时，执行CLI和STI指令将引起通用保护异常，而其他4条指令是否能够执行要根据访问的I/O地址及任务的I/O许可位图来决定，如果条件不满足时，那么将引起保护异常。



**I/O许可位图的保护**

• 只用IOPL来限制I/O指令的执行会使得在特权级3执行的应用程序要么可以访问所有I/O地址，要么不能访问所有I/O地址，使用很不方便。

• 在任务状态段中设置了I/O许可位图。每个任务的I/O许可位图都可以由操作系统来设置。I/O许可位图就是一个二进制位串。位串中的每一位对应一个I/O地址，位串的第0位对应I/O地址0，位串的第n位对应I/O地址n。如果位串中的第n位为0，那么I/O地址n就可以由任何特权级的程序访问，而不加限制；如果第n位为1，I/O地址n只能由在IOPL特权级或更高特权级运行的程序访问

• 如果一条I/O指令涉及多个I/O地址，例如“IN EAX, DX”涉及4个I/O地址，则在检查许可位时，这条指令用到的所有I/O地址的许可位都必须为0才允许访问。

• Intel 80x86系列计算机的I/O地址空间范围是0000H～0FFFFH，所以I/O许可位图的二进制位串最大为8KB。

• TSS内偏移66H的字确定I/O许可位图在TSS段中的位置，即I/O位图基址。I/O许可位图的大小s等于TSS段的长度减去I/O位图基址，它定义了I/O地址空间0～s×8–1的许可位。CPU认为大于或等于s×8的I/O地址许可位全部为1。

• 由于I/O许可位图最长可达8KB，所以开始偏移应小于56KB，但必须大于等于104B，因为TSS中前104字节为TSS的固定格式，用于保存任务的状态。

**对IOPL的保护**

• 只有在特权级0下执行的程序才可以修改IOPL位及VM位；只有IOPL级或更高的特权级的程序才可以修改IF位。指令POPF不能改变VM位，而PUSHF指令所压入的标志中的VM位总为0。



## Chapter 3 指令系统

• 一台计算机所拥有的全部指令的集合构成了它的指令系统。

• CPU的每一次升级都伴随着指令集的更新与扩充。

• 一条指令通常由操作码域和操作数域两部分组成，操作码域指示计算机要执行的操作，操作数域则提供与操作数或操作数地址有关的信息。

### 数据寻址方式

• 寻址方式分为与数据有关的寻址方式和与转移地址有关的寻址方式。
• MOV 目标, 源 ;把源操作数传送给目标
• MOV是实现数据传送功能的操作码助记符，简称为操作码。目标和源是操作数，中间用逗号隔开。注释内容从“;”开始。

#### 立即数寻址

• 操作数直接包含在指令中，紧跟在操作码之后的寻址方式称为立即寻址方式。
• MOV BL,9 ;执行结果（BL）= 9
• MOV EAX,1234H ;执行结果（EAX）= 1234H
• 只能出现在源操作数的位置

#### 寄存器寻址方式 

• 操作数直接包含在寄存器中，由指令指定寄存器的寻址方式。

• 寄存器可以是通用寄存器，包括8位、16位、32位通用寄存器。 也可以是段寄存器，但目标寄存器不能是CS。 

• MOV ECX, 9AH 

• MOV BX, AX 

• 速度快，数量少，个别操作受限制，比如段寄存器。

#### 直接寻址方式 

• 从这个寻址方式开始，操作数位于存储器中。 

• 操作数的有效地址Effective Address（EA）直接包含在指令中的寻址方式称为直接寻址方式。

![image-20230112154055457](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230112154055457.png)

• MOV EAX, [00404011H]
• [00404011H]是直接寻址方式的一种表示形式。
• 注意这里的00404011H用[ ]括起来，它是一个普通变量的有效地址，而不是操作数本身。
• MOV EAX, VAR
• VAR是一个内存变量名，它代表一个内存单元的符号地址。

##### 段超越

• 1、2、4寻址类型，可以使用段超越前缀显式地说明。段超越前缀的功能是明确指出本条指令所要寻址的内存单元在哪个段。
• 段寄存器名:存储器寻址方式。
• MOV EBX, ES: MEM

#### 寄存器间接寻址方式 

• 操作数的有效地址在寄存器而操作数本身在存储器中的寻址方式 称为寄存器间接寻址方式。 

• 对于16位寻址，这个寄存器只能是基址寄存器BX、BP或变址寄存 器SI、DI；对于32位寻址，允许使用任何32位通用寄存器。 

• 指令中使用的是BX、SI、DI、EAX、EBX、ECX、EDX、ESI、EDI， 则默认操作数在数据段，即它们默认与DS段寄存器配合；若使用 的是BP、EBP、ESP，则默认操作数在堆栈段，即它们默认与SS段 寄存器配合。

• MOV AL, [BX] 

• 运行在实模式下，若（DS）= 3000H，（BX）= 78H，（30078H） = 12H，则物理地址 = 10H ×（DS）+（BX）= 30078H，该指令 的执行结果是（AL）= 12H。 

• MOV AX, [BP] 

• 运行在实模式下，若（SS）= 2000H, （BP）= 80H，（20080H） = 12H，（20081H）= 56H，则物理地址= 10H ×（SS）+（BP） = 20080H，该指令的执行结果是（AX）= 5612H。

#### 寄存器相对寻址方式

• 操作数的有效地址是一个寄存器的内容和指令中给定的一个位移量（disp）之和。

• 对于16位寻址，这个寄存器只能是基址寄存器BX、BP或变址寄存器SI、DI；对于32位寻址，允许使用任何32位通用寄存器。

• 位移量可以是8位、16位、32位（只适用于32位寻址情况）的带符号数。

• 与段寄存器的配合情况同寄存器间接寻址方式。

• 使用BP、EBP、ESP，则默认与SS段寄存器配合；使用其他通用寄存器，则默认与DS段寄存器配合。

• 允许使用段超越前缀。

• MOV AL, 8[BX] ;8是位移量

• 也可以表示为：MOV AL, [BX+8]

• 实模式下，若（DS）= 3000H，（BX）= 70H，（30078H）= 12H

• 则物理地址=10H ×（DS）+（BX）+ 8 = 30078H，该指令的执行结是（AL）= 12H。

• 使用这种寻址方式可以访问一维数组。

• 其中，TABLE是数组起始地址的偏移量（即数组名），寄存器中是数元素的下标乘以元素的长度（一个元素占用的字节数）

• 下标从0开始计数。

#### 基址变址寻址方式

• 对于16位寻址，操作数的有效地址是一个基址寄存器（BX、BP）和一个变址寄存器（SI、DI）的内容之和。

• 对于32位寻址，允许使用变址部分除ESP以外的任何两个32位通用寄存器的组合。

• 默认使用段寄存器的情况由所选用的基址寄存器决定。若使用BP、ESP或EBP，默认与SS配合；若使用BX或其他32位通用寄存器（386以上），则默认与DS配合。

• 允许使用段超越前缀。

• EA =（基址寄存器）+（变址寄存器）

• MOV AL, [BX][SI] / MOV AL, [BX+SI]

• MOV EAX, [ EBX ] [ ESI ]

#### 相对基址变址寻址方式

• 对于16位寻址，操作数的有效地址是一个基址（BX、BP）和一个变址寄存器（SI、DI）的内容和指令中给定的一个位移量（disp）之和。

• 对于32位寻址，允许使用变址部分除ESP以外的任何两个32位通用寄存器及一个位移量的组合。

• 默认段寄存器与基址变址寻址方式相同。

• 可以访问形如ARY[3][2]的二维数组

• MOV AL, ARY[BX] [SI] / MOV AL, ARY [BX+SI]

• MOV EAX, ARY[EBX] [ESI]

#### 比例变址寻址方式

• 80386以上的微处理器才提供的

• 基址部分（8个32位通用寄存器）、变址部分（除ESP以外的32位通用寄存器）乘以比例因子、位移量（disp）。比例因子可以是1（默认值）、2、4或8

• 位移量可以是8位、32位的带符号数。

• 默认使用段寄存器的情况由所选用的基址寄存器决定。若使用ESP或EBP，默认与SS配合；若使用其他32位通用寄存器，默认与DS配合。

• 允许使用段超越前缀。

• 有效地址EA=（基址寄存器）+（变址寄存器）× 比例因子 + disp

• MOV EAX, ARY[EBX] [ESI] ;（DS:[ARY+EBX+ESI]）→ EAX

• MOV ECX,[EAX+2* EDX] ;（DS:[EAX+2* EDX]）→ ECX

• MOV EBX,[EBP+ECX* 4+10H] ;（SS:[EBP+ECX* 4+10H]）→ EBX

• MOV EDX, ES:ARY[4* EBX] ;（ES:[ARY+4* EBX]）→ EDX

### 数据运算指令

#### MOV

• 数据传送指令

• 数据传送指令可以实现数据、地址、标志的传送。除了目标地址为标志寄存器的传送指令外，其他指令不影响标志。

• 格式：MOV DST, SRC

• 功能：SRC（源）→DST（目标）

• 源操作数和目标操作数的数据类型，即应同为字节、字或双字型数据。

• 立即数不能作为目标操作数；立即数不能直接送段寄存器；目标寄存器不能是CS

• 两个段寄存器间不能直接传送；

• 两个存储单元之间不能直接传送。

**例子**

• MOV AL, 5

• MOV BL, 'A' ;  字符A的ASCII码41H送BL

• MOV AX, BX

• MOV BP, DS

• MOV DS, AX

• MOV [EBX], EAX

• MOV ES:VAR, 12

• MOV WORD PTR [EBX], 12

• MOV EAX, EBX

• MOV DWORD PTR [EBX], 12

• “DWORD PTR”，它明确指出EBX所指向的内存单元为双字型

• 要生成8 / 16位的二进制数，则需要用“BYTE PTR / WORD PTR”

**对错**
• MOV 1000H, EAX; 错误原因：立即数作为目标操作数

• MOV DS, 1000H ; 错误原因：立即数直接送段寄存器

• MOV VAR, [EBX] ; 错误原因：两个存储单元之间直接传送

• MOV CS, AX ; 错误原因：目标寄存器是CS

• MOV ES, DS ; 错误原因：两个段寄存器间直接传送



**借助于FFSET和SEG操作符，实现地址传送**

• MOV AX, SEG TAB ;把TAB的段基址送给AX寄存器

• MOV DI, OFFSET TAB ;把TAB的偏移量送给DI寄存器

##### MOVSX

带符号扩展的数据传送指令

• MOVSX指令只有80386以上CPU提供。

• 格式：MOVSX DST, SRC

• 功能：SRC→DST，DST空出的位用SRC的符号位填充。

• 说明：DST必须是16位或32位寄存器操作数，SRC可以是8位或16位的寄存器或存储器操作数，但不能是立即数。

• MOV DL, 98H

• MOVSX AX, DL ;AX中得到98H的带符号扩展值0FF98H

• MOV CX, 1234H

• MOVSX EAX, CX ;EAX中得到1234H的带符号扩展值00001234H

• MOV VAR, 56H

• MOVSX AX, VAR ;AX 中得到56H的带符号扩展值0056H

##### MOVZX

带零扩展的数据传送指令

• MOVZX指令只有80386以上CPU提供。

• 格式：MOVZX DST,SRC

• 功能：SRC→DST，DST空出的位用0填充。

• 说明：DST必须是16位或32位寄存器操作数；SRC可以是8位或16位的寄存器或存储器操作数，但不能是立即数。

• MOV DL, 98H

• MOVZX AX, DL ;AX中得到98H的带零扩展值0098H

• MOV CX, 1234H

• MOVZX EAX, CX ;EAX中得到1234H的带零扩展值00001234H

• MOV VAR, 56H

• MOVZX AX, VAR ;AX 中得到56H的带零扩展值0056H

### 堆栈操作指令

• 栈基地址放在SS堆栈段寄存器中，栈顶地址放在SP（16位）或 ESP（32位）堆栈指针寄存器中

#### 进栈指令PUSH

• PUSH SRC

• 功能：先修改堆栈指针使其指向新的栈顶（若SRC是16位操作数，则堆栈指针减2，若SRC是32位操作数则堆栈指针减4），然后把SRC压入到栈顶单元。

• 在8086、8088中，SRC只能是16位寄存器操作数或存储器操作数，不能是立即数。在80286以上的机器中，SRC可以是16位或32位（80386以上）立即数、寄存器操作数、存储器操作数。

• 设操作数及堆栈地址长度均为16位

• PUSH AX

• PUSH 1234H ;80286以上可用

![image-20230113142219765](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113142219765.png)

#### 出栈指令POP

• POP DST

• 功能：先把堆栈指针所指向单元的内容弹出到DST，然后修改堆栈指针以指向新的栈顶（若SRC是16位操作数则堆栈指针加2，若SRC是32位操作数则堆栈指针加4）

• DST可以是16位或32位（80386以上）的寄存器操作数和存储器操作数，也可以是除CS寄存器以外的任何段寄存器。

• 设操作数及堆栈地址长度均为16位。

• POP BX

• POP AX

![image-20230113142301100](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113142301100.png)

#### 交换指令XCHG
• 格式：XCHG OPR1, OPR2

• 功能：交换两个操作数。

• 说明：OPR是操作数，可以是8位、16位、32位（80386以上），两个操作数均不能是立即数，可以是寄存器操作数和存储器操作数，并且其中之一必须是寄存器操作数。

• XCHG AX, BX

• XCHG ECX, WORD PTR [EBX]

### 输入输出指令

• 外设端口独立编址，所以指令系统应提供专门的输入/输出指令。

• IN, OUT

• 结合IOPL和IO位图

#### 输入指令IN
• 格式：IN ACR, PORT 

• 功能：把外设端口（PORT）的内容传送给累加器（ACR）。

• 说明：可以传送8位、16位、32位（80386以上）的数据，相应的累加器选择AL、AX、EAX。若端口号在0～255之间，则端口号直接写在指令中；若端口号大于255，则端口号通过DX寄存器间接寻址，即端口号应先放入DX中。

• IN AL, 61H ;把61H端口的字节内容输入到AL

• IN AX, 20H ;把20H端口的字内容输入到AX

• MOV DX, 3F8H

• IN AL, DX ;把3F8H端口的字节内容输入到AL

• IN EAX, DX ;把DX所指向的端口双字内容输入到EAX

#### 输出指令OUT

• 格式：OUT PORT, ACR

• 功能：把累加器的内容传送给外设端口。

• 说明：对累加器和端口号的选择限制与IN指令相同

• OUT 61H, AL ;把AL寄存器的内容输出到61H端口

• OUT 20H, AX ;把AX内容输出到20H端口

• MOV DX, 3F8H

• OUT DX, AL ;把AL寄存器的内容输出到3F8H端口

• OUT DX, EAX ;把EAX内容输出到DX所指向的端口

### 地址传送指令
• 传送有效地址指令LEA（Load Effective Address），指令传送的是操作数的地址（逻辑），而不是操作数本身。

• 格式：LEA REG, SRC

• 功能：把源操作数的有效地址送给指定的寄存器。

• 说明：源操作数必须是存储器操作数。

• LEA BX, ASC ;同MOV BX, OFFSET ASC指令

• LEA BX, ASC[SI] ;把DS:[ASC+SI]单元的16位偏移量送给BX

• LEA DI, ASC[BX] [SI];把DS:[ASC+BX+SI]单元的16位偏移量送给DI

• LEA EAX, 6[ESI] ;把DS:[6+ESI]单元的32位偏移量送给EAX

### 标志传送指令
• POPF、POPFD、SAHF指令影响标志位，其他不影响。

#### 16位标志进栈指令PUSHF

Push Flags Register onto the Stack

• 格式：PUSHF

• 功能：先使堆栈指针寄存器SP减2，然后压入标志寄存器FLAGS的内容到栈顶单元。

#### 16位标志出栈指令POPF

Pop Stack into Flags Register

• 格式：POPF

• 功能：先把堆栈指针所指向的字弹出到FLAGS，然后使堆栈指针寄存器SP加2。

• 标志：影响FLAGS中的所有标志。

#### 32位标志进栈指令PUSHFD

Push Eflags Register onto the Stack

• 格式：PUSHFD

• 功能：先使堆栈指针寄存器ESP减4，然后压入标志寄存器EFLAGS的内容到栈顶单元。

#### 32位标志出栈指令POPFD

Pop Stack into Eflags Register

• 格式：POPFD

• 功能：先把堆栈指针所指向的双字弹出到EFLAGS，然后使堆栈指
针寄存器ESP加4。

• 标志：影响EFLAGS中的所有标志。

### 类型转换指令
• 把操作数的最高位进行扩展，用于处理带符号数运算的操作数类型匹配问题。

• 这类指令均不影响标志。

#### CBW

字节扩展成字指令（Convert Byte to Word）

• 格式：CBW

• 功能：把AL寄存器中的符号位值扩展到AH中。

• MOV AL, 5

• CBW ;执行结果为（AX）= 0005H

• MOV AL, 98H

• CBW ;执行结果为（AX）= 0FF98H

#### CWD

字扩展成双字指令（Convert Word to Doubleword）

• 格式：CWD

• 功能：把AX寄存器中的符号位值扩展到DX中。

• MOV AX, 5

• CWD ;执行结果为（DX）= 0，AX值不变

• MOV AX, 9098H

• CWD ;执行结果为（DX）= 0FFFFH，AX值不变

#### CDQ

双字扩展成四字指令（Convert Doubleword to Quad-Word）

• 格式：CDQ

• 功能：把EAX寄存器中的符号位值扩展到EDX中。

• 说明：80386以上CPU支持此指令。

• MOV EAX, 5

• CDQ ;执行结果为（EDX）= 0，EAX值不变

• MOV EAX, 90980000H

• CDQ ;执行结果为（EDX）= 0FFFFFFFFH，EAX值不变

#### CWDE

AX符号位扩展到EAX指令（Convert Word to Doubleword Extended）

• 格式：CWDE

• 功能：把AX寄存器中的符号位值扩展到EAX的高16位。

• 说明：80386以上CPU支持此指令。

• MOV AX, 5

• CWDE ;执行结果为（EAX31～EAX16）= 0，AX值不变

• MOV AX, 9098H

• CWDE ;执行结果为（EAX31～EAX16）= 0FFFFH，AX值不变

### 算术运算指令
• 包括二进制和十进制算术运算指令

• 两个操作数寻址方式的限定同MOV指令，即目标操作数不允许是立即数和CS段寄存器，两个操作数不能同时为存储器操作数等。

• 除类型转换指令外，其他指令均影响某些运算结果特征标志。

#### 二进制加法指令

• 每一条均适用于带符号数和无符号数运算。

##### 加法指令ADD（Add）

• 格式：ADD DST, SRC

• 功能：（DST）+（SRC）→ DST

• 说明：对于操作数的限定同MOV指令。即源和目标均可以是8位、16位、32位的操作数；要注意源和目标操作数的类型匹配，即它们的长度要一致；目标不能是立即数和CS段寄存器，两个操作数不能同时为存储器操作数等。

• 标志：影响OF、SF、ZF、AF、PF、CF标志。

• ADD AX, 535

• ADD AL, '0'

• ADD WORD PTR[BX], 56

• ADD EDX, EAX

##### 带进位加法指令ADC（Add with Carry）

• 格式：ADC DST, SRC

• 功能：（DST）+（SRC）+ CF → DST

• 说明：除了执行时要加进位标志CF的值外，其他要求同ADD。因为它考虑了CF，所以可用于数值是多字节或多字的加法程序。

• 标志：影响OF、SF、ZF、AF、PF、CF标志。

• ADC AX, 35 ;执行后（AX）=（AX）+ 35 + CF

• 多字节加法

##### 加1指令INC（Increment）

• 格式：INC DST

• 功能：（DST）+ 1 → DST

• 说明：使用本指令可以很方便地实现地址指针或循环次数的加1修改。

• 标志：不影响CF标志，影响其他5个算术运算特征标志。

• INC BX

##### 互换并加法指令XADD（Exchange and Add）

• 格式：XADD DST, SRC

• 功能：（DST）+（SRC）→ TEMP，（DST）→ SRC，TEMP → DST。

• 说明：TEMP是临时变量。该指令执行后，原DST的内容在SRC中，和在DST中。只有80486以上CPU才支持XADD指令。

• 标志：影响OF、SF、ZF、AF、PF、CF标志。

• XADD AL, BL

• 若（AL）= 16H，（BL）= 35H，
• （AL）= 4BH，（BL）= 16H。

##### 关于溢出

• 同一个加法运算，分别解释为无符号数和带符号数，溢出的情况不一定一致。

• 1100+0101

• 无符号数相加结果若使CF置1，则表示溢出；带符号数相加结果若使OF置1，则表示溢出。

![image-20230113153650251](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113153650251.png)

#### 二进制减法指令
• 每一条均适用于带符号数和无符号数运算

##### 减法指令SUB（Subtract）

• 格式：SUB DST, SRC

• 功能：（DST）-（SRC）→DST

• 说明：除了是实现减法功能外，其他要求同ADD。

• 标志：影响OF、SF、ZF、AF、PF、CF标志。

• SUB AX, 35

• SUB AL, '0'

• SUB WORD PTR[BX], 56

• SUB EDX, EAX

##### 带借位减法指令SBB（Subtract with Borrow）
• 格式：SBB DST, SRC

• 功能：（DST）-（SRC）- CF→DST

• 说明：除了操作时要减进位标志CF的值外，其他要求同ADC。因为它考虑了CF，所以可用于数值是多字节或多字的减法程序。

• 标志：影响OF、SF、ZF、AF、PF、CF标志。

• SBB AX, 35 ;执行后（AX）=（AX）- 35 – CF

• 多字节减法

##### 减1指令DEC（Decrement）

• 格式：DEC DST

• 功能：（DST）- 1→DST

• 说明：使用本指令可以很方便地实现地址指针或循环次数的减1修改。

• 标志：不影响CF标志，影响其他5个算术运算特征标志。

• DEC BX

#### 比较指令CMP（Compare）

• 格式：CMP DST, SRC

• 功能：（DST）-（SRC），影响标志位。

• 说明：这条指令执行相减操作后只根据结果设置标志位，并不改变两个操作数的原值。其他要求同SUB。CMP指令常用于比较两个数的大小。

• 标志：影响OF、SF、ZF、AF、PF、CF标志。

• CMP AX, [BX]

#### 求补指令NEG（Negate）

• 格式：NEG DST

• 功能：对目标操作数（含符号位）求反加1，并且把结果送回目标。即实现0 -（DST）→DST。

• 说明：利用NEG指令可实现求一个数的相反数。

• 标志：影响OF、SF、ZF、AF、PF、CF标志。

• 编写两个3字节长的二进制数加法程序，加数FIRST、SECOND及和SUM的分配情况如图所示。

![image-20230113153724151](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113153724151.png)

• LEA DI, SUM ;建立和的地址指针DI

• ADD DI, 2 ;DI指向和的低字节

• MOV BX, 2

• MOV AL, FIRST[BX] ;取FIRST的低字节（本例为33H）

• ADD AL, SECOND+2 ;两个低字节相加，和①在AL中，进位反映在CF中

• MOV [DI], AL ;把低字节和存到DI指向的单元（本例为SUM+2单元）

• DEC DI ;修改和指针，使其指向中字节

• DEC BX ;修改加数指针，使其指向中字节

• MOV AL, FIRST[BX] ;取FIRST的中字节（本例为22H）

• ADC AL, SECOND+1 ;两个中字节相加且加CF，和②在AL中,进位反映在CF中

• MOV [DI], AL ;把中字节和存到DI指向的单元（本例为SUM+1单元）

• DEC DI ;修改和指针，使其指向高字节

• DEC BX ;修改加数指针，使其指向高字节

• MOV AL, FIRST[BX] ;取FIRST的高字节（本例为11H）

• ADC AL, SECOND ;两个高字节相加且加CF，和③在AL中,进位反映在CF中

• MOV [DI], AL ;把高字节和存到DI指向的单元（本例为SUM单元）

1.两个ADC指令能否换为ADD？

否。因为在对高字节计算时要考虑到低字节的进位，这个进位在执行上一条加法指令时已反映在CF中。

2.DEC DI和SUB DI, 1指令是否可以互换？
否。因为上一条加法指令对CF的影响后边要用到，所以不能破坏CF值，
使用DEC指令正好不影响CF。

3.等价替换指令
PUSHF ;保存包括CF的 FLAGS值
SUB DI,1 ;修改DI
POPF ;恢复原FLAGS值

#### 多字节运算溢出情况判断

• 若是两个无符号数相加，则当最后一次的CF被置1时，表示溢出，结果不正确；若是两个带符号数相加，则当最后一次的OF被置1时，表示溢出，结果不正确。

#### 二进制乘法指令

• 分无符号数和带符号数二进制乘法指令
##### 无符号数乘法指令MUL（Unsigned Multiple）

• 格式：MUL SRCreg／m

• 功能：实现两个无符号二进制数乘。

• 说明：该指令只含一个源操作数，必须注意这个源操作数只能是寄存器（reg）或存储器操作数（m），不能是立即数。另一个乘数必须事先放在累加器中。该指令可以实现8位、16位、32位无符号数乘。若源操作数是8位的，则与AL中的内容相乘，乘积在AX中；若源操作数是16位的，则与AX中的内容相乘，乘积在DX:AX这一对寄存器中；若源操作数是32位（80386以上）的，则与EAX中的内容相乘，乘积在EDX:EAX这一对寄存器中。

• 字节型乘法：（AL）×（SRC）8 →AX
• 字型乘法：（AX）×（SRC）16 →DX:AX
• 双字型乘法：（EAX）×（SRC）32 →EDX:EAX 
• 标志：若乘积的高半部分（例：字节型乘法结果的AH）为0，则对CF和OF清0，否则置CF和OF为1。其他标志不确定。
• MOV AL, 8
• MUL BL ;（AL）×（BL），结果在AX中
• MOV AX, 1234H
• MUL WORD PTR [BX] ;（AX）×（[BX] ），结果在DX:AX中
• MOV EAX, 0F901H
• MUL EBX ;（EAX）×（EBX），结果在EDX:EAX中

##### 带符号数乘法指令IMUL（Signed Multiple）

• 功能：实现两个带符号二进制数乘。

• IMUL SRCreg／m

• 说明：这种格式的指令除了是实现两个带符号数相乘且结果为带符号数外，其他均与MUL指令相同。所有的80x86 CPU都支持这种格式。

• 字节型乘法：（AL）×（SRC）8 →AX
• 字型乘法：（AX）×（SRC）16 →DX:AX
• 双字型乘法：（EAX）×（SRC）32 →EDX:EAX 
• 标志：若乘积的高半部分（例：字节型乘法结果的AH）为低半部分的符号扩展，则对CF和OF清0，否则置CF和OF为1。其他标志不确定。
• MOV AL, 8
• IMUL BL ;（AL）×（BL），结果在AX中
• MOV AX, 1234H
• IMUL WORD PTR [BX] ;（AX）×（[BX]），结果在DX:AX中
• MOV AL, 98H
• CBW ; AL中的符号扩展至字
• IMUL BX ;（AX）×（BX），结果在DX:AX中
• MOV AX, 1234H
• CWDE ; AX中的符号扩展至EAX
• IMUL ECX ;（EAX）×（ECX），结果在EDX:EAX中
• IMUL REG, SRCreg／m

• 说明：REG和SRC的长度必须相同，目标操作数REG必须是16位或32位通用寄存器，源操作数SRC可以是寄存器或存储器操作数。
具体操作为：
（REG）16 ×（SRC）16 →REG16
（REG）32 ×（SRC）32 →REG32
• 标志：若乘积完全能放入目标寄存器（例如：若目标REG是16位的，则结果的有效数字不超过16位），则对CF和OF清0，否则置CF和OF为1。其他标志不确定。
• IMUL CX, WORD PTR [BX] ;（CX）×（[BX] ），结果在CX中
• IMUL ECX, EBX ;（ECX）×（EBX），结果在ECX中
• IMUL REG, imm8
• 说明：目标操作数REG可以是16位或32位通用寄存器，源操作数imm8只能是8位立即操作数，计算时系统自动对其进行符号扩展。
 具体操作为：
（REG）16 × imm8符号扩展→REG16
（REG）32 × imm8符号扩展→REG32
• 标志：对标志位的影响同格式2。
• IMUL CX, 98H ;（CX）× 0FF98H，结果在CX中
• IMUL CX, 68H ;（CX）× 0068H，结果在CX中
• IMUL REG, SRCreg／m , imm8
• 说明：REG和SRC的长度必须相同，目标操作数REG必须是16位或32位通用寄存器；源操作数SRC可以是寄存器或存储器操作数；操作数imm8正如它的英文缩写那样，只能是8位立即操作数。
具体操作为：
（SRC）16 × imm8符号扩展→REG16
（SRC）32 × imm8符号扩展→REG32
• 标志：对标志位的影响同格式2。
• IMUL CX, BX, 98H ;（BX）× 0FF98H，结果在CX中
• IMUL ECX, DWORD PTR [EBX], 68H;（[EBX]）× 0068H，结果在ECX中

#### 二进制除法指令
• 与乘法类似，对无符号数和带符号数分别提供了二进制除法指令。
##### 无符号数除法指令DIV（Unsigned Divide）
• 格式：DIV SRCreg／m
• 功能：实现两个无符号二进制数除法。
• 说明：该指令只含一个源操作数，该操作数作为除数使用，注意它只能是寄存器或存储器操作数，不能是立即数。被除数必须事先放在隐含的寄存器中。可以实现8位、16位、32位无符号数除。若源操作数是8位的，则被除数在AX中，商在AL中，余数在AH中；若源操作数是16位的，则被除数在DX:AX一对寄存器中，商在AX中，余数在DX中；若源操作数是32位（80386以上）的，则被除数在EDX:EAX一对寄存器中，商在EAX中，余数在EDX中。

![image-20230113153749432](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113153749432.png)

• 实现1000 ÷ 25的无符号数除法。
• MOV AX, 1000
• MOV BL, 25
• DIV BL ;（AX） ÷（BL），商在AL中，余数在AH中
• 实现1000 ÷ 512的无符号数除法。
• MOV AX, 1000
• SUB DX, DX ; DX清0
• MOV BX, 512
• DIV BX ;（DX:AX）÷（BX），商在AX中，余数在DX中

##### 带符号数除法指令IDIV（Signed Divide）

• 格式：IDIV SRCreg／m
• 功能：实现两个带符号二进制数除。
• 说明：除了是实现两个带符号数相除且商和余数均为带符号数外，其他均与DIV指令相同。余数符号与被除数相同。

• 实现（-1000）÷（+25）的带符号数除法。
• MOV AX, -1000
• MOV BL, 25
• IDIV BL ;（AX）÷（BL），商在AL中，余数在AH中

• 实现1000 ÷（-512）的带符号数除法。
• MOV AX, 1000
• CWD ; AX的符号扩展到DX
• MOV BX, -512
• IDIV BX ;（DX:AX）÷（BX），商在AX中，余数在DX中

#### 位运算指令
• 逻辑运算指令

• 逻辑运算指令包括逻辑非（NOT）、逻辑与（AND）、逻辑测试（TEST）、逻辑或（OR）和逻辑异或（XOR）指令。这些指令的操作数可以是8位、16位、32位，其寻址方式与MOV指令的限制相同。

• 逻辑非指令可用于把操作数的每一位均变反的场合；逻辑与指令用于把某位清0（与0相与，也可称为屏蔽某位）、某位保持不变（与1相与）的场合；逻辑测试指令可用于只测试其值而不改变操作数的场合；逻辑或指令用于把某位置1（与1相或）、某位保持不变（与0相或）的场合；逻辑异或指令用于把某位变反（与1相异或）、某位保持不变（与0相异或）的场合

![image-20230113151210595](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113151210595.png)

• 对AL中的值按位求反。
• MOVAL, 00001111 B
• NOT AL ;（AL）= 11110000 B
• 将EAX寄存器清0。
• AND EAX, 0
• 把AL中的0～9二进制值转换成十进制数的ASCII码形式输出。
• OR AL, 30H ;AL中的高4位变成0011 B，低4位不变
• 使61H端口的D1位变反。
• IN AL, 61H
• XOR AL, 2
• OUT 61H, AL
• 将EAX寄存器清0。
• XOR EAX, EAX
• 这种清0方式比用MOV AX, 0指令占用空间少，执行速度快。
• 转换AL中字母的大小写。
• XOR AL, 20H

• 设某并行打印机的状态端口是379H，其D7位是忙闲位。若D7为0表示忙，为1表示闲，测试该打印机的当前状态，若为忙则继续测试，否则顺序执行下一条指令。
• MOV DX, 379H
• WT: IN AL, DX;读入状态字节
• TEST AL, 80H ;只关心D7位，其他位屏蔽，若结果使ZF=1，表示D7=0
• JZ WT ;若ZF=1则跳转到WT继续测试，否则顺序执行下一条指令

#### 位测试指令

• 80386开始增加了位测试指令

• 包括BT（Bit Test）、BTS（Bit Test and Set）、BTR（Bit Test and Reset）和BTC（Bit Test and Complement）

• 这些指令可以直接对一个16位或32位的通用寄存器或存储单元中的指定二进制位进行必要的操作，它们首先把指定位的值送给CF标志，然后对该位按照指令的要求操作。

![image-20230113153809238](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113153809238.png)

• 目标可以是16位或32位的寄存器或存储器操作数，源可以是8位的立即数、寄存器或存储器操作数

• 若是后两种情况，其长度一定要和目标的长度相同。若源操作数是立即数形式，则其值不应超过目标操作数的长度。目标操作数的位偏移从最右边位开始，从0开始计数。

• MOV EAX, 2357H
• MOV ECX, 3
• BT AX, 0 ;CF=1，（AX）= 2357H
• BT AX, CX ;CF=0，（AX）= 2357H
• BTS EAX, ECX ;CF=0，（EAX）= 235FH
• BTR AX, CX ;CF=0，（EAX）= 2357H
• BTC AX, 3 ;CF=0，（EAX）= 235FH

![image-20230113151424628](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113151424628.png)

• 可以用于对一个数进行2n的倍增或倍减运算，使用这种方法比直接使用乘除法效率要高得多。可以用逻辑移位指令实现无符号数乘除法运算，只要移出位不含1，SHL DST, n执行后是原数的2n倍，SHR DST, n执行后是原数的1/2n。可以用算术右移指令实现带符号数除法运算，只要移出位不含1，SAR DST, n执行后就是原数的1/2n。

• 设无符号数X在AL中，用移位指令实现X×10的运算。
• MOV AH, 0 ;为了保证不溢出，将AL扩展为字
• SAL AX, 1 ;求得2X
• MOV BX, AX ;暂存2X
• MOV CL, 2 ;设置移位次数
• SAL AX, CL ;求得8X
• ADD AX, BX ;10X=8X+2X

![image-20230113151509331](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113151509331.png)

• 把CX:BX:AX一组寄存器中的48位数据左移一个二进制位。
• SHL AX, 1
• RCL BX, 1
• RCL CX, 1
• 在没有溢出的情况下，以上程序实现了2 ×（CX:BX:AX）→ CX:BX:AX的功能。

### 程序控制指令
• 转移指令的寻址方式

• 以无条件转移指令为例来说明。

• 无条件转移指令格式：JMP 目标

• 该指令的功能是无条件转移到目标处，这里的目标有各种寻址方式，这些寻址方式可以被分为段内转移和段间转移两类，每一类又可分为直接转移和间接转移。

• 段内转移只影响指令指针IP或EIP的值；段间转移既要影响IP或EIP的值，也要影响代码段寄存器CS的值。

#### 段内直接寻址方式

• 转向的有效地址是当前指令指针寄存器的内容和指令中指定的位移量（disp）之和，该位移量是一个相对于指令指针的带符号数。

• 这种寻址方式是一种相对寻址方式，指令代码不会因为在内存的不同区域运行而发生变化

![image-20230113151818720](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113151818720.png)

• 短转移

• 若位移量是8位的，则称为短转移，短转移可以实现在距离下条指令的-128～+127字节范围内转移。其汇编格式为：

• JMP SHORT LAB
• JMP SHORT L1
• MOV BL, CL
• …
• L1: ADD AL, 61H

**标号/行号**

• “L1:”是一条指令地址的符号表示，叫做标号，标号名由程序员确定，所包含字符应符合名字的要求，并必须以冒号结束。

• 近转移

• 若位移量是16位或32位的，则称为近转移。当位移量是16位时，把其加到当前IP值中形成转向的目标地址，其跳转范围为±32 KB，当位移量是32位时，把其加到当前EIP值中形成目标地址，其跳转范围为±2 GB。

• JMP LAB 或 JMP NEAR PTR LAB
• JMP L2 ;转向同段内的L2标号处
• JMP NEAR PTR L3 ;转向同段内的L3标号处

#### 段内间接寻址方式

![image-20230113151914907](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113151914907.png)

• 实模式下，设（DS）= 2000H，（BX）= 300H，（IP）= 100H，（20300H）= 0，（20301H）= 05H，则：

• JMP BX ;执行后（IP）=（BX）= 0300H
• JMP WORD PTR [BX]

• 这条指令执行时，先按照操作数寻址方式得到存放转移地址的内存单元：10H ×（DS）+ （BX）= 20300H，再从该单元中得到转移地址，即EA =（20300H）= 0500H，于是，（IP）= EA = 0500H，下一次便执行CS:0500H处的指令，实现了段内间接转移。

#### 段间直接寻址方式

![image-20230113151953005](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113151953005.png)

• 段间转移在实模式下的16位编程时使用比较多，这是因为它的段长限定不能超过64 KB，对于一个大程序可能会包含多个代码段。但对于保护模式下的32位程序设计，由于此时代码段的长度可达4GB，足够存放一个应用程序的全部代码，包括该程序调用的所有DLL，因此一般并不需要段间转移的JMP指令，只有在切换任务、跳转到调用门指定的程序入口或者确需执行另一个代码段内的程序时才使用。

#### 段间间接寻址方式

• 用一个双字内存变量（称为32位指针）中的低16位取代IP值，高16位取代CS值，从而实现段间转移。
• 当操作数长度为32位时，则是用一个三字内存变量（称为48位全指针）中的低32位取代EIP值，高16位取代CS值。该双字或三字变量的地址可以由除立即寻址方式和寄存器寻址方式以外的其他与数据有关的寻址方式获得。
• JMP DWORD PTR [BX]

假设（DS）= 2000H，（BX）= 0300H，（IP）= 0100H，（20300H）= 0，（20301H）= 05H，（20302H）= 10H，（20303H）= 60H，则这条指令执行时有：
• 10H ×（DS）+（BX）= 20300H
• 再把该单元中的低字送给IP，高字送给CS，即0500H→IP，6010H→CS，下一次便执行6010:0500H处的指令，实现了段间间接转移。

• JMP FWORD PTR [EBX]
• FWORD PTR [EBX]表示EBX指向一个三字变量。
• 这条指令执行时，先按照与操作数有关的寻址方式得到存放转移
地址的内存单元，然后把低32位的值送给EIP，高16位值送给CS，
从而实现段间间接转移。

### 转移指令

• 包括无条件转移指令、条件转移指令、测试CX／ECX值为0转移
指令，通过它们可以实现程序的分支转移。

#### 无条件转移指令
• JMP DST
• 功能：无条件转移到DST所指向的地址。
• 说明：DST为转移的目标地址（或称转向地址）

##### 段内直接短转移

• 格式：JMP SHORT LABEL

##### 段内直接转移

• 格式：JMP LABEL或 JMP NEAR PTR LABEL

##### 段内间接转移

• 格式：JMP REG／M
• 把B2的偏移量送给通用寄存器，通过寄存器实现段内间接转移。
• LEA EBX, B2
• JMP EBX ;转向地址B2在EBX中
• 把B2的偏移量送给内存单元，通过内存单元实现段内间接转移。
• VAR DWORD ？ ;为存放标号B2的偏移量预留一个双字型内存变量
• MOV VAR, OFFSET B2 ;把B2的偏移量送给变量VAR
• JMP DWORD PTR VAR ;转向地址在VAR变量中
• JMP DWORD PTR [EBX] [ESI]
• JMP DWORD PTR disp[EBX] [ESI]

##### 段间直接转移

• JMP FAR PTR LABEL
##### 段间间接转移

• JMP DWORD PTR M（16位）/ JMP FWORD PTR M（32位）
• 实模式下，把B3的双字长地址指针放在变量VAR1中，即可通过VAR1实现段间间接转移（保护模式采用变量VAR2存储，存储类型FWORD）。
• VAR1 DWORD B3 ;初始化B3的偏移量在VAR1中
• JMP DWORD PTR VAR1 ;通过VAR2无条件转移到其他段的B3标号处
• VAR2 FWORD B3 ;初始化B3的偏移量在VAR2中
• JMP FWORD PTR VAR2 ;通过VAR2无条件转移到其他段的B3标号处

#### 条件转移指令

• 当需要满足条件则转移到程序的另一处，不满足条件则顺序执行
下一条指令时使用条件转移指令（Jump if Condition is True）
• 这类指令本身并不影响标志
• JCC LABEL
• 功能：如果条件为真，则转向标号处，否则顺序执行下一条指令。
• 其中CC为条件，LABEL是要转向的标号。在8086～80286中，该
地址应在距离当前IP值-128～+127 B范围之内，即只能使用与转
移地址有关的寻址方式的段内短转移格式，其位移量是8位带符
号数。从80386开始，转移范围扩大到了段内任意位置，它们可
以使用段内直接近转移格式。

![image-20230113152333341](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113152333341.png)

• 比较EAX和EBX寄存器中的内容，若相等执行ACT1，不等执行ACT2。

![image-20230113152350774](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113152350774.png)

根据两个带符号数比较结果实现转移的条件转移指令

![image-20230113152402230](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113152402230.png)

根据两个无符号数比较结果实现转移的条件转移指令

![image-20230113152413015](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113152413015.png)

• 设M =（EDX:EAX），N =（EBX:ECX），比较两个64位数。若M＞N，则转向DMAX，否则转向DMIN。

![image-20230113152428430](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113152428430.png)

• 分析：先比较高32位，若（EDX）＞（EBX），则M＞N；若高32位相等，再比较低32位，若（EAX）＞（ECX），则M＞N。

#### 测试CX/ECX值为0的转移指令

• 测试的是CX或ECX寄存器的内容是否为0，而不是测试标志位。
这类指令只能使用段内短转移格式，即位移量只能是8位的。
• JCXZ LABEL ;适用于16位操作数长度
• JECXZ LABEL ;适用于32位操作数长度
• 功能：测试CX（ECX）寄存器的内容，当CX（ECX）= 0时则转移，否则顺序执行。

• 说明：此指令经常用于在循环程序中判断循环计数的情况。

### 循环类指令

• 循环指令可以控制程序的循环。对于80x86系列，所有循环指令的循环入口地址都只能在距离当前IP值的-128～+127B范围之内，即位移量只能是8位的，所以它们只能使用与转移地址有关的寻址方式的段内短转移格式。所有循环指令都用CX或ECX作为循环次数计数器，它们都不影响标志。

• CX/ECX初始值为0时，不是循环零次。

#### 循环指令

• LOOP LABEL
• 功能：LOOP（Loop）循环指令，（CX）-1→CX，若（CX）≠0，则转向标号处执行循环体，否则顺序执行下一条指令。
• 说明：对固定次数的循环，适合用LOOP指令来实现。若操作数长度为32位，则其中的CX应为ECX。在LOOP指令前，应先把循环计数的初始值送给CX（ECX）。

#### 相等循环指令

• LOOPE/LOOPZ LABEL
• 功能：LOOPE/LOOPZ（Loop while Equel/Zero）相等循环指令，
（CX）-1→CX，若（CX）≠0 and ZF=1，则转向标号处执行循环体，否则顺序执行下一条指令。

• 说明：若操作数长度为32位，则CX应为ECX。在LOOPE或LOOPZ指令前，应先把循环计数的初始值送给CX（ECX）。

• 该指令常用于比较两个字符串是否相等的情况，若前面的字符相等才有必要继续比较，否则中止比较。

#### 不等循环指令

• LOOPNE/LOOPNZ LABEL

• 功能：LOOPNE/LOOPNZ（Loop while Not Equel/ Not Zero）不等循环指令，（CX）-1→CX，若（CX）≠0 and ZF=0，则转向标号处执行循环体，否则顺序执行下一条指令。

• 说明：若操作数长度为32位，则CX应为ECX。在LOOPNE或LOOPNZ指令前，应先把循环计数的初始值送给CX（ECX）。该指令对在数据块中查找信息很有效，当未找到指定字符时继续查找，找到时退出。用累加的方法实现M×N，并把结果保存到RESULT单元。假设M、N为32位无符号数。

• 分析：把N个M累加，若用EAX作为累加器并初始化为0，则共累加N次，即把乘数N作为循环次数送给ECX。注意N有可能为0。而当初始化ECX为0时，使用LOOP指令要循环232次而不是0次，因此一定要在循环前判断ECX是否为0，若为0则乘积直接赋为0而循环体一次也不要执行。
• MOV EAX, 0 ;累加器清0
• MOV EDX, 0
• MOV EBX, M
• CMP EBX, 0
• JZ TERM ;被乘数为0则跳转
• MOV ECX, N
• JECXZ TERM ;乘数为0则跳转
• L1: ADD EAX, EBX
• ADC EDX, 0
• LOOP L1 ;累加次数未到则跳转到L1执行循环体，否则继续
• TERM:MOV RESULT, EAX ;保存结果低32位
• MOV RESULT+4, EDX ;保存结果高32位

### 子程序调用与返回指令

• 汇编语言中的子程序相当于C语言中的函数。为便于模块化程序设计和程序共享，在汇编语言中经常把一些相对独立的程序段组织成子程序的形式。当需要实现该子程序功能时，由调用程序（或泛称为主程序）调用它，当子程序结束后再返回到主程序继续执行。

![image-20230113152650157](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113152650157.png)

#### 子程序调用指令

• 格式：CALL DST

• 功能：CALL（Call procedure）调用子程序。执行时先把返回地址压入堆栈，再形成子程序入口地址，最后把控制权交给子程序。

• 其中DST为子程序名或子程序入口地址，其目标地址的形成除了不能使用段内直接短转移格式外，其他与JMP指令相同。它有段内直接／间接调用、段间直接／间接调用之分。CALL指令的执行结果也是无条件转移到标号处，它与JMP指令的不同之处在于：前者转移后要返回，所以要保存返回地址，而后者转移后不再返回，所以不必保存返回地址。

##### 段内调用

• 这类调用指令可实现同一段内的子程序调用，它只改变IP（32位长度时是EIP）值，不改变CS值。
• 首先把CALL之后的那条指令地址的偏移量部分（当前IP或EIP值）压入堆栈；接着根据与转移地址有关的寻址方式形成子程序入口地址的IP（或EIP）值；最后把控制无条件转向子程序。

###### 段内直接调用

• 格式：CALL PROCEDURE 或 CALL NEAR PTR PROCEDURE
• 功能：调用PROCEDURE子程序。执行时先把返回地址（当前IP值或EIP值）压入堆栈，再使IP（或EIP）加上指令中的位移量，最后把控制权交给子程序。
• 说明：这种指令使用段内直接寻址方式。
• 设子程序A与CALL指令在同一段内，则调用A子程序的指令是：
• CALL A 或 CALL NEAR PTR A

###### 段内间接调用

• 格式：CALL REG／M
• 功能：调用子程序。执行时先把返回地址（当前IP值或EIP值）压入堆栈，再把指令指定的通用寄存器或内存单元的内容送给IP（16位）或EIP（32位），最后把控制权交给子程序。
• 说明：这种指令使用段内间接寻址方式，指令指定的通用寄存器或内存单元中存放段内偏移量。
• 可以把子程序入口地址的偏移量送给通用寄存器或内存单元，通过它们实现段内间接调用。
• CALL EBX ;子程序入口地址的32位偏移量在EBX寄存器中
• CALL WORD PTR [BX];子程序入口地址的16位偏移量在数据段的BX所指向的字型内存单元中
• CALL DWORD PTR [EBX] ;子程序入口地址的32位偏移量在数据段的EBX所指向的双字型内存单元中

##### 段间调用

###### 段间直接调用

• 格式：CALL FAR PTR PROCEDURE
• 功能：调用PROCEDURE子程序。执行时先把返回地址（当前IP值和CS值）压入堆栈，再把指令中的偏移量部分送给IP，段基址部分送给CS，最后把控制权交给子程序。对于保护模式，执行时先把当前EIP值压入堆栈，再把当前CS值压入堆栈（注意CS是16位的，但是应以32位形式入栈，其中高16位无意义），然后再把指令中的偏移量部分送给EIP，段选择符部分送给CS，最后把控制权交给子程序。
• 设子程序B与CALL指令不在同一段内，则段间直接调用B子程序的指令是：
• CALL FAR PTR B

###### 段间间接调用

• 格式：CALL M
• 功能：调用子程序。执行时先把返回地址（当前指令指针寄存器值和当前CS值）压入堆栈，再把M的16位或32位送给指令指针寄存器，高16位送给CS，最后把控制权交给子程序。
• 说明：段间间接寻址方式，转向地址放在内存变量中。对于8086等16位机，用双字变量的低16位取代指令指针寄存器IP值，高16位取代CS值实现段间转移。在保护模式下，由于偏移量是32位的，则转向地址只能放在内存的3字长（用FWORD定义）变量中，用三字变量的低32位取代指令指针寄存器EIP值，高16位取代CS值实现段间转移。该双字或三字变量的地址由与存储器操作数有关的寻址方式获得。
• 若子程序B的入口地址（偏移量和段基址）放在变量VAR中，即可通过VAR实现段间间接调用。如下所示：
• CALL DWORD PTR VAR
• CALL FWORD PTR [EBX] [EDI]
• ;从DS:[EBX+EDI]单元中得到子程序的入口地址实现调用

#### 子程序返回指令
• 执行这组指令可以返回到被调用处。有两条返回指令，它们都不影响标志。

#### 返回指令RET

Return from procedure
• 格式：RET
• 功能：按照CALL指令入栈的逆序，从栈顶弹出返回地址送指令指针寄存器IP（或EIP），若子程序是FAR型还需再弹出一个字到CS（若为32位操作数，则弹出一个双字，其中低字送CS，高字丢弃），然后返回到主程序继续执行。
• 无论子程序是NEAR型还是FAR型，返回指令的汇编格式总是用RET表示。但经汇编后会产生不同的机器码。在DEBUG中，段间返回指令被反汇编成RETF。

#### 带立即数的返回指令

• 格式：RET imm16
• 功能：按照CALL指令入栈的逆序，从栈顶弹出返回地址（偏移量送IP或EIP，若子程序是FAR型还需再弹出一个字到CS），返回到主程序，并修改栈顶指针SP =（SP）+ imm16。若为32位操作数则使用ESP。
• 注：其中imm16是16位的立即数，设通过堆栈给子程序传递了n个字型参数，则imm16=2n；若传递了n个双字型参数，则imm16=4n。
• 修改堆栈指针是为了废除堆栈中主程序传递给子程序的参数。
• 保护模式的段间调用与返回操作很复杂，好在这些复杂性对在Windows下的32位汇编语言编程人员是不可见的，我们只需会使用汇编级指令即可。例如：系统会自动为准备要运行的用户程序的代码段、数据段和堆栈段全部定义好段描述符的内容，并且把CS、DS、ES、SS等段选择符指向正确的描述符

#### 中断调用与返回指令

• 中断就是使计算机暂时挂起正在执行的进程而转去处理某事件，处理完后再恢复执行原进程的过程。对某事件的处理实际上就是去执行一段例行程序，该程序被称为中断处理例行程序或中断处理子程序，简称为中断子程序。中断分为内中断（或称软中断）和外中断（或称硬中断）

• 中断向量
• 中断向量就是中断处理子程序的入口地址。在PC中规定中断处理子程序为FAR型，所以8086的每个中断向量占用4个字节，其中低两个字节为中断向量的偏移量部分，高两个字节为中断向量的段基址部分。

• 中断类型号
• PC共支持256种中断，相应编号为0～255，把这些编号称为中断类型号。

• 中断向量表
• 256种中断应该有256个中断处理子程序，显然应有256个中断向量，把这些中断向量按照中断类型号由小到大的顺序排列形成一个中断向量表，该表长为4×256=1024字节，从内存的0000:0000地址开始存放，占用内存最低端的0～3FFH单元

• 内中断调用指令
• 内中断调用指令INT是程序员根据需要在程序的适当位置安排的。它完全受程序控制，不像外中断那样由硬件随机产生。
• 格式：INT n
• 其中，n为中断类型号。
• 功能：中断当前正在执行的程序，把当前的FLAGS、CS、IP值依次压入堆栈（保护断点），并从中断向量表的4n处取出n类中断向量，其中（4n）→ IP，（4n+2）→ CS，然后转去执行中断处理子程序。
• INT 21H
• 21H中断为系统功能调用中断，执行时把当前的FLAGS、CS、IP值依次压入堆栈，并从中断向量表的84H处取出21H类中断向量，其中（84H）→ IP，（86H）→ CS，然后转去执行中断处理子程序。

#### 中断返回指令

• 当从中断处理子程序返回时要使用中断返回指令IRET和IRETD，中断返回指令应放在中断处理子程序的末尾。一般将16位实模式代码中的中断返回指令写做IRET，而将32位保护模式代码中的中断返回指令写做IRETD。
• 在实模式下，IRET从栈顶弹出3个字分别送入IP、CS、FLAGS寄存器（按中断调用时的逆序恢复断点），把控制返回到原断点继续执行。在保护模式下，IRETD从栈顶弹出3个双字分别送入EIP、CS、EFLAGS寄存器），返回被中断的程序。
• 保护模式下把这里所称的中断分为中断和异常两大类，系统并不使用中断向量表而是使用中断描述符表IDT，其中每个描述符8个字节，描述符中包含中断子程序16位的段选择符和32位的偏移量等信息。在响应中断或者处理异常时，CPU把中断类型号作为中断描述符表IDT中描述符的索引，取得一个描述符，从中得到中断/异常处理程序的入口地址。

### 处理机控制指令

![image-20230113153257205](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113153257205.png)

![image-20230113153310526](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113153310526.png)

### 块操作指令

![image-20230113153455207](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113153455207.png)

![image-20230113153504478](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113153504478.png)

• 源操作数和目标操作数
• 块操作指令的源操作数是DS:[ESI]所指向的内存单元；目标操作数
是ES:[EDI]所指向的内存单元。ESI是源操作数的地址；EDI是目标
操作数的地址。

（1）MOVSB/W/D将ESI所指向的字节/字/双字复制到EDI所指向的字节/字/双字。
（2）CMPSB/W/D将ESI和EDI所指向的字节/字/双字进行比较。
（3）SCASB/W/D将EDI所指向的字节/字/双字和AL/AX/EAX进行比较。
（4）STOSB/W/D将AL/AX/EAX保存到EDI所指向的字节/字/双字中。
（5）LODSB/W/D将ESI所指向的字节/字/双字读入到AL/AX/EAX中。

#### 方向标志和地址指针
• 块操作指令会自动地修改ESI和EDI，使它们指向下一个源操作数
和目标操作数。CPU的EFLAGS中有一个标志位DF，由DF来决定
ESI和EDI是增加还是减小。DF=0时，地址增加；DF=1时，地址
减小。

#### 重复前缀

• 重复前缀一共有3种形式：REP，REPZ，REPNZ，它放在块操作指令的前面。
• 使用重复前缀时，ECX的作用是给出内存中连续操作数的个数，也就是块操作指令的最大重复次数。每执行一次块操作指令，ECX就自动减1。ESI和EDI自动修改。

![image-20230113153520390](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230113153520390.png)

#### 块操作指令示例

• 数组复制
• 将数组Array1复制给数组Array2。
• Array1 DWORD 1, 10, 100, 1000, 10000
• Array2 DWORD 5 DUP (0)
• LEA ESI, Array1
• LEA EDI, Array2
• CLD
• MOV ECX, 5
• REP MOVSD
• 缓冲区初始化
• 将数组Array1的每个元素的初值设为0H。
• dArray DWORD 7 DUP (?)
• LEA EDI, dArray ; EDI指向第1个存储单元
• CLD ; 地址由低至高
• MOV ECX, 7 ; 存储7次
• MOV EAX, 0 ; 存储内容为0
• REP STOSD ; 以双字为单位存储

## Chapter 4 汇编语言程序开发



## Chapter 5 子程序设计

## Chapter 6 存储系统与技术

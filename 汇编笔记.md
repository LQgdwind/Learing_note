# 汇编笔记

**2023寒假简单学一点汇编知识**

## Chapter 1 主板和内存

### 主板

主板（Main Board，Mother Board，System Board）是微型机各种硬件的载体。微型机的CPU、内存及芯片组等部件都安装在一块电路板上，这块电路板称为主机板（主板）。

![image-20230102102419131](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230102102419131.png)



#### 主板结构

• AT、ATX和BTX三大类

• AT结构主要在早期的微型计算机中使用，目前已经被淘汰。AT结构的初始设计是让扩展总线以微处理器相同的时钟速率来运行。

• 扩展AT（Advanced Technology eXtended）主板结构，即ATX主板标准，取代了AT主板规格。

• BTX（Balanced Technology eXtended）是Intel公司2003年发布的新型主板架构，目标是取代ATX结构。新架构的发展目标是完全取消传统的串口、并口、PS/2等接口，并很好支持PCI Express和串行ATA等新技术。



#### 芯片组

• 芯片组（Chipset）是主板的核心组成部分

• 几乎决定了主板的全部功能

• 包括控制芯片组、主板BIOS芯片和CMOS芯片等





#### 控制芯片组

• 南北桥体系结构

• CPU+北桥+南桥的体系结构

• 内存控制器：北桥芯片

• I/O控制器：南桥芯片



#### 南北桥体系结构

![image-20230103084931553](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230103084931553.png)



**北桥芯片**

• 控制CPU、内存和图形加速器接口（AGP）等设备之间的数据传输

• 主板上靠近CPU插槽的位置。发热量一般较高，通常需要安装散热片

• 内存控制器中心（Memory Controller Hub，MCH）

• 前端总线FSB 由MCH提供，目前是64位

• 芯片组的名称就是以北桥芯片的名称来进行命名

• MCH芯片的类型决定着RAM的类型和容量

• 早期MCH提供的显卡接口是AGP（Accelerated Graphics Port）总线接口，但现在已被数据传输速率更快的PCI-E取代



**南桥芯片**

• I/O控制中心（I/O Controller Hub，ICH）

• 负责对I/O设备的读写控制和数据的传输处理，提供各种外部设备的接口来实现硬、软盘和光驱等设备之间的数据传输

• 一般在远离CPU插槽，靠近PCI槽的位置，这种布局是考虑到它所连接的I/O总线较多，离处理器远一点有利于布线

• IDE（Integrated Drive Electronics）控制器、USB（Universal Serial Bus）控制器、PCI控制器、音频控制器、SATA（Serial Advanced Technology Attachment）控制器和网络控制器、

DMA控制器、中断控制器、定时/计数器、实时时钟控制器RTC（Real-Time Clock）和CMOS RAM

• ICH10是最后一个版本→PCH平台控制器

• 支持6条PCI-E通道、4个主PCI接口、12个USB 2.0接口、并支持USB接口禁用功能，支持6个SATA 3Gbps接口



#### 单芯片组体系结构

• CPU+南桥的单芯片组体系结构

• 内存控制器、北桥芯片的其它部分包括GPU核心、PCI-E控制器等都被集成到CPU里面

![image-20230103092526668](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230103092526668.png)



#### BIOS及CMOS芯片

• BIOS（Basic Input/Output System，基本输入/输出系统）全称是ROM-BIOS，只读存储器基本输入输出系统

• 开机上电自检程序和系统启动自举程序、系统设置信息

• 早期的BIOS多为可重写EPROM芯片，现在多采用Flash ROM(可擦可编程只读存储器)

• CMOS芯片是电脑主板上的一块可读写的RAM芯片，用它来保存当前系统的硬件配置和用户对某些参数的设定。现在做到了BIOS芯片中

• CMOS电池



### 内存



#### 常用概念

**存储器容量**

• 存储器的容量以字节（byte）为单位，用大写字母B表示。

• 以字节编址，包含8个二进制位（bit）

• 二进制位用小写字母b表示。

• 在描述比较大的存储容量时，经常使用KB、MB、GB、TB等单位。



**内存地址及内容**

• 每个单元分配了一个唯一的地址，地址从0开始编号，顺序递增1



**字节、字、双字**

• 字节：字节是PC机中内存存取信息的基本单位，1个字节包含8个二进制位

• 字：1个字包含16个二进制位，即两个字节，分别称为高字节和低字节。

• 双字：1个双字包含32个二进制位



**存储器访问**

• 单字节数据访问

• 多字节数据访问

• 小端存储：低字节在前（Little Endian）的存储格式。即低地址中存放低字节数据，高地址中存放高字节数据

• 访问这些数据时只需给出最低单元的地址号



#### 单通道内存技术

• 单通道系统中，北桥芯片内部只有一个内存控制器，系统安装的多个内存条连接到同一个内存总线上。多个内存条相当于串行工作，一次只有一个内存条工作，内存条数目增多，只能增加容量，并不能增加带宽。

例子： 假定2条DDR 400内存条，工作在200MHz频率下，每个时钟可以传送2次64位数据，则单通道系统中内存总线的总带宽是多少？

200M×2×64÷8 = 6400MB/s = 3.2 GB/s



#### 双通道内存技术

• 芯片组有两个内存控制器，构成双通道内存总线（Dual Channel Memory Bus）

• 与内存本身无关，任何DDR内存都可工作在支持双通道技术的主板上

• 内存条利用并联方式运行，当连接两条内存时，总线宽度达到64×2=128位

• 双通道要求按主板上内存插槽的颜色成对使用，如双通道系统中安装两条2GB的内存比安装一条4GB的效果要好

例子：假定2条DDR 400内存条，工作在200MHz频率下，每个时钟可以

传送2次64位数据。双通道系统中内存总线的总带宽是多少？

 2×200M×2×64÷8 = 6400MB/s = 6.4GB/s



#### 三通道内存技术

• 随着Intel Core i7平台发布而出现，是双通道内存技术的后续技术发展

• 将同色的三根内存插槽插上内存即可，系统会自动识别，并进入三通道模式

• 如果插上非3或非6条的内存，如4根内存，系统会自动进入单通道模式。





### 接口与插槽

#### 主板插槽

• CPU插槽

• 接口方式有引脚式、卡式、触点式、针脚式

• 常见的CPU插槽类型可分为Slot架构和Socket架构两种

#### 内存插槽

• 早期的8位和16位SIMM(Single Inline Memory Module)内存模组使用30Pin接口

• 32位SIMM模组使用72Pin接口

• SDRAM开始使用DIMM结构的插槽

• SDRAM DIMM为168Pin DIMM结构，每面为84Pin，有两个卡口，

用来避免插入插槽时，错误将内存反向插入

• DDR DIMM则采用184Pin DIMM结构，每面有92Pin，只有一个卡口

• DDR2、DDR3 DIMM为240Pin DIMM结构，每面有120Pin

#### 电源插槽

• 有AT电源插座和ATX电源插座两种

• AT电源插座为12芯单列插座，目前已被淘汰

• ATX电源插座早期为D型20芯双列插座

• 从ATX 12V 2.0开始，电源接口从传统的20芯升级为24芯，多出的4芯主要是为解决功耗较大的PCI-E显卡供电问题

• CPU电源

• 4芯的+12V接插头，单独向处理器供电

• 服务器平台上由于对供电要求更高，很早引入了更强的8PIN 12V接口

#### PCI 插槽

• PCI（Peripheral Component Interconnect，外设部件互连总线）Intel公司1991年推出的用于定义局部总线的标准，支持即插即用

• 在CPU和原来的ISA总线之间插入的一级总线

• 工作频率一般为33MHz/66MHz，提供32位和64位两种位宽

• 33MHz下最大数据传输率为133MB/sec(32位)和266MB/sec(64位)

• 目前被PCI-E（PCI Express）逐步取代

#### PCI-E插槽

• 完全兼容PCI

• 较短的PCI-E卡可以插入较长的PCI-E插槽中使用，支持热拔插

#### IDE接口

• 也称作并行ATA（Parallel ATA）

• ICH有2个IDE通道，每个通道上可以连接2个IDE设备（如硬盘、光驱等），其中一个为主设备（Master），另一个为从设备（Master）

• 已经被SATA接口所取代

#### SATA

• Serial ATA

• 采用串行方式传输数据，只需要7芯电缆就能连接主板和硬盘。结构简单，支持热插拔，数据传输可靠性高，传输的速度达到600MB/s甚至更高

#### 机箱连接线

• 用来连接主板和机箱面板

• 计算机状态指示以及外延主板开关和接口

• 一般黑色/白色为负，其他颜色为正

#### 外部接口

• 主要包括用于操作控制、音视频输入/输出、网络接入、外置存储接入等接口

#### PS/2接口

• 来源于Personal 2，IBM个人电脑

• 用于鼠标、键盘等设备的输入装置接口，不是传输接口

• 只有采样率，没有传输速率

• 一般情况下，PS/2接口的鼠标为绿色，键盘为紫色

#### VGA、DVI和HDMI接口

• VGA是传输模拟信号，DVI和HDMI传输数字信号。后两者传输数字信号的抗干扰性和传输稳定性比VGA好。与DVI相比，HDMI主要优势是能够同时传输音频数据，在视频数据的传输上没有差别

#### USB接口

• 1996年Intel牵头推出

• 是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范

• 目前为3.0版本，传输速度达到4.8Gbps

• 已取代原有的串口和并口

#### e-SATA接口

• 扩展的SATA接口

• 让外部I/O接口使用SATA功能

• 并不是一种独立的外部接口技术标准

• 拥有e-SATA接口的电脑，可以把SATA设备直接从外部连接到系统当中，而不用打开机箱。

## Chapter 2 微处理器管理模式

### 微处理器基本结构

![image-20230104091007504](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104091007504.png)

#### CPU

‘• 中央处理部件（Central Process Unit，CPU）由指令部件和执行部件组成。指令部件包括指令预取单元（Instruction Prefetch Unit，IUP）和指令译码单元（Instruction Decode Unit，IDU）两部分。

• 指令预取负责从存储器取出指令，放到一个16字节的FIFO指令队列中，这个队列叫做指令预取队列。

• 指令译码单元从指令预取队列中取出指令，进行译码，并将译码后的可执行指令放入已译码指令队列中。

• 执行部件(Execution Unit，EU)执行从已译码指令队列中取出的指令。它包含8个32位通用寄存器、32位的算术运算单元ALU、1个64位的移位器和乘/除硬件。

• 如果是算术、逻辑或者移位指令，则交给ALU处理，若指令执行时需要段或者页单元产生操作数地址（寻址），则交给分段或者分页单元进行处理。

#### BIU

• 总线接口部件（Bus Interface Unit，BIU）通过数据总线、地址总线、控制总线来与外部环境联系，包括从存储器中预取指令、读写数据，从I/O端口读写数据，以及其他的控制功能。

• 数据总线和地址总线都是32位的。

• 从存储器中存储数据最快也需要两个时钟周期内完成。

#### MMU

存储器管理单元由分段部件和分页部件组成，提供存储器管理和保护服务，实现从逻辑地址到物理地址的转换，既支持段式存储管理、页式存储管理，也支持段页存储管理。



### CPU工作模式

![image-20230104091533208](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104091533208.png)

#### 实模式

• CPU被复位（加电）时，自动进入实模式。在实模式下，这些CPU就相当于高性能的8086，使用1MB地址空间以及16位的“段首址:偏移”的地址格式。

• 全部权限

#### 保护模式

• CPU支持内存分页机制，提供段式和页式内存管理功能，协助操作系统高效地实现虚拟内存，支持多任务和特权级等。

• 保护模式下CPU执行JMP/CALL/IRET等指令，就可实现任务切换。

• 分为特权级0、1、2、3

#### 虚拟8086模式

• 兼容以前的DOS及应用程序（即8086程序），从80386开始增加了虚拟8086模式（V86模式）

• 86模式是以任务形式在保护模式上执行的，每个任务都有自己的任务状态段，各个V86任务所拥有的1MB地址空间相互独立

• 特权指令，如屏蔽中断指令CLI、中断指令INT、中断返回指令IRET等，在DOS程序中是合法的。如果不让这些指令在V86模式中执行，DOS程序就无法工作。为了解决这个问题，V86管理程序采用模拟的方法来完成这些指令。

### 寄存器

• 微处理器内部的寄存器可以分为:

• 程序可见的寄存器（Program Visible Register）

• 程序不可见的寄存器（Program Invisible Register）

• 80386以上CPU才包含程序不可见寄存器组

#### 程序可见寄存器

• Intel 8086~Core2（包括64位扩展）

![image-20230104092437820](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104092437820.png)

#### 通用型寄存器

![image-20230104092510901](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104092510901.png)

• 通用寄存器功能中RAX，RBX，RCX和RDX可以作为64位，32位，16位和8位寄存器使用，微处理器访问不同长度数据时，可以直接利用表中的命名。

• 如利用MOV指令修改DX的值：MOV DX，0010h。指令给DX寄存器赋值0010h，指令执行结果只会改变寄存器低16位，RDX的其他部分保持不变。又如EAX的值为6BC30E9FH，那么，AX=0E9FH（AH=0EH，AL=9FH）。

#### 64位中新增（非扩展）寄存器

• R8~R15共8个64位寄存器。这些寄存器可以按照字节、字、双字或者四字方式寻址。

![image-20230104092630576](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104092630576.png)

#### 段寄存器

段寄存器

• 80286以前的CPU有4个段寄存器，分别称为代码段寄存器CS（Code Segment），数据段寄存器DS（Data Segment），堆栈段寄存器SS（Stack Segment），附加数据段寄存器ES（Extra Segment）。自80386 CPU开始，增加了FS和GS两个段寄存器。

• 分段：基于逻辑

• 分页：基于管理

• 实模式：段地址+段内偏移

• 保护模式：段选择符

• 这些段寄存器都是16位的，对于16位CPU段长度限制为2 16B=64KB，对于32位CPU段长度限制为2 32B=4GB，

• 实模式和V86模式下它们的用法兼容16位CPU，即段寄存器保存20位段首址的高16位，段首址的低4位为0。

• 在保护模式下，不直接存放段基址，而是存放一个索引，称之为段选择符（Segment Selector）。由段选择符从全局描述符表或局部描述符表中找到8个字节长的段描述符，从而确定关于这个段的全部描述信息。

• RPL（Requestor Privilege Level）：请求特权级，表示将要访问的段的特权级。取值范围为0～3。

• TI（Table Indicator）：表指示符。为0时，从全局描述符表（GDT）中选择描述符；为1时，从局部描述符表（LDT）中选择描述符。

![image-20230104093547153](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104093547153.png)

• Index：索引。指出要访问描述符在段描述符表中的顺序号，Index占13位。因此，顺序号的范围是0～8191。每个段描述符表（GDT或LDT）中最多有8192=213个描述符。

![image-20230104093658899](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104093658899.png)

例子：

DS=0023H

DS=0023H=0000 0000 0010 0011b，可知：Index=0 0000 0000 0100b=4。TI=0，RPL=11b=3。因为TI=0，DS的段描述符在GDT中。Index×8=4×8=0020H，该描述符在GDT表中的位置是0020H～0027H，占8个字节。RPL=3，请求特权级为3。

#### 专用寄存器

• Intel 8086~Core2专用型寄存器包括：指令指针寄存器、堆栈指针寄存器和标志寄存器等。

##### 指令指针寄存器IP/EIP/RIP

• 指令指针指向程序的下一条指令。

• 当微处理器为8086/8088，80286或者工作在实模式下时，这个寄存器取16位IP；80386以及更高型号的微处理工作于保护模式下时这个寄存器取32位EIP。在64位模式中，RIP包含40位地址总线。

• 指令指针可以由转移指令或者调用指令修改（间接）。

##### 堆栈指针寄存器SP/ESP/RSP

• 堆栈指针，指向栈顶单元。

这个寄存器作为16位寄存器时使用SP；

作为32位寄存器时，使用ESP；

64位使用RSP。

##### 标志寄存器FLAGS/EFLAGS /RFLAGS

• 用来指示微处理器状态并控制它的操作。

• 从8086开始直到Pentium微处理器向上兼容。

• 8086/8088和80286使用16位FLAGS寄存器。80386以及更高微处理器使用32位EFLAGS寄存器。64位版本中的RFLAGS包含EFLAGS和FLAGS寄存器

• 状态位+控制位

###### 进位标志CF（Carry Flag）

• 当结果的最高位（字节操作时的第7位或字操作时的第15位）产生一个进位或借位，CF＝1，否则CF＝0。

• 在移位或循环移位指令中，会把操作数的最高位（左移时）或最低位（右移时）移入CF中。

###### 奇偶标志PF（Parity Flag）

• Intel微处理器中采用奇校验，当执行结果的低8位中二进制1的个数为奇数时，PF为0，否则为1。

• 不考虑其他位

• 6DH+6DH=DAH

• DAH=1101 1010B，结果中有5个1，因此PF为0。

###### 辅助进位标志AF（Auxiliary Carry Flag）

• 在字节操作时若低半字节（一个字节的低4位）向高半字节有进位或借位；在字操作时若低位字节向高位字节有进位或借位，则AF＝1，否则AF＝0。

• 这个标志用于十进制算术运算指令中，即通过二进制数运算调整为十进制数表示的结果。(BCD）

• 零标志ZF（Zero Flag），当运算结果为零时，ZF为1；否则为0。

• 符号标志SF（Sign Flag），它与运算结果的最高位相同。对字节操作（

8位运算）来说，是结果的第7位；对字操作（16位运算）来说，是结果的第15位。当SF＝0时，结果为正数或0；当SF＝1时，结果为负数。

• 单步标志TF（Trap Enable Flag），当TF=1时，CPU进入单步方式，在每条指令执行以后产生一个内部中断（单步中断）。当TF＝0时，CPU执行指令后不产生单步中断。

• 中断允许标志IF（Interrupt Enable Flag），当IF=1时，允许CPU接收外部中断请求，此时为“开中断”状态。当IF=0时，屏蔽外部中断请求，此时为“关中断”状态。

• 方向标志DF（Direction Flag），在字符串操作指令中，当DF=0时，串操作为自动增址；当DF=1时，串操作为自动减址。STD指令置位DF，CLD指令清除DF。

• 溢出标志OF（Overflow Flag），带符号数运算时，当其运算结果超出了8位或16位带符号数所能表达的范围时，将产生溢出，置OF为1，否则OF清0。溢出OF与进位CF是两个不同性质的标志。

• IOPL（I/O Privilege Level），表示I/O特权级，IOPL占2位，取值为0、1、2、3对应四个特权级。只有特权级高于IOPL的程序才能够执行I/O指令，否则会产生异常，并将任务挂起。

• NT（Nest Task），嵌套任务位，此位只用于保护模式，如果保护模式下当前的任务嵌套在其他任务中，此位为1，否则为0。IRET指令会检测NT的值。若NT=0，则执行中断的正常返回；若NT＝1，则执行任务切换操作。

• VM（Virtual 8086 Mode），V86模式位。VM=1时，表示当前CPU正工作在V86模式下；VM=0，表示当前CPU工作在实模式或保护模式下。VM位只能在保护方式中由IRET指令置位（如果当前特权级为0）或在任意特权级上通过任务切换而置位。

###### 486以上新增标志位：ID、VIP，VIF和AC

• AC（Alignment Check），地址对齐检查位。寻址一个字或者双字时，当地址不在字或者双字的边界上，此时AC=1，否则AC=0。

• VIF（Virtual Interrupt Flag），虚拟中断标志，与VIP一起使用，在虚拟方式下提供中断允许标志位IF的副本。

• VIP（Virtual Interrupt Pending），虚拟中断挂起标志，为Pentium~Pentium 4处理器提供有关虚拟模式中断的信息，它用于多任务环境下，为操作系统提供虚拟中断标志和中断挂起信息。

• ID（Identification）微处理器标识标志，用来指示Pentium~Pentium 4处理器，支持CPUID指令。CPUID指令是Intel IA-32架构下获得CPU信息的汇编指令，可以得到CPU类型、型号、制造商、商标、序列号、缓存等一系列CPU相关的信息。

#### 控制寄存器

• CR0～CR3（Control Register）。

• CR0的低5位是系统控制标志，被称为机器状态字（Machine Status Word，MSW）

• 分页机制中用到CR3、CR2和CR0。

![image-20230104094317012](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104094317012.png)

• PE（Protection Mode Enable）：保护模式允许标志。PE=0为实模式，CPU复位时自动进入实模式；PE=1为保护模式。可以通过软件设置PE进入或退出保护模式。

• MP（Monitor Coprocessor Extension）：运算协处理器存在位，MP=1表示系统中有协处理器。

• EM（Emulate Processor Extension）：仿真位。设置该位可以使每条ESC指令引起7号中断（ESCape指令用来对80387协处理器指令编码）。EM=1时，可以利用7号中断，用软件来仿真协处理器的功能；EM=0时用硬件控制浮点指令。• TS（Task Switched）：任务切换标志。TS=1时表明任务已经切换，在保护模式下，TR的内容改变将自动设置此位为1。

• ET（Extension Type）：协处理器选择标志，早期80386里面没有80387协处理器，因此设置此位。当处理器复位时，ET位被初始化以指示系统中数字协处理器的类型。如果系统中存在 80387协处理器，那么ET位置1；如果系统中存在80287协处理器或者不存在协处理器，那么ET位清0。80386以后的系统中ET位被置为1表示系统中存在协处理器。

• PG（Paging Enable）：分页标志。PG=1时，存储器管理单元允许分页，线性地址通过页表转换获得物理地址。PG=0时，分页功能被关闭，线性地址等于物理地址。当PG=0时，CR2和CR3寄存器无效，PG=1时二者用于分页管理机制。

##### 分页-页面

• 每页大小为4KB。CR3也被称做页目录基址寄存器PDBR（Page Directory Base Register），它的高20位用于保存页目录表的起始物理地址的高20位。

• 向CR3中装入一个新值时，低12位必须为0，这是由于页目录是页对齐的，所以仅高20位有效，低12位保留未用；从CR3中取值时，低12位被忽略。

• CR2也被称做页面故障线性地址寄存器（Page Fault Linear Address Register），用于发生页异常时报告出错信息。如在访问某个线性地址时，该地址的所在页没有在内存中，则发生页异常，处理器把引起页异常的线性地址保存在CR2中。

#### 全局描述符表寄存器

• 全局描述符表（Global Descriptor Table，GDT）是用来定义全局存储器空间的一种机制，它用段描述符来描述一个全局存储器中的段，每个GDT最多含有2 <sup>13</sup>=8192个描述符（8192×8=64KB）。

• 全局描述符表可以存储在内存的任何位置，通过全局描述符表寄存器（Global Descriptor Table Register，GDTR）给出它的位置和大小。LGDT指令可以将描述符表的起始位置装入GDTR。

• GDTR是48位的寄存器。其最低16位是限长，给出GDT的字节大小（其值比GDT的长度少1），其高32位是基址，指出GDT在物理存储器中存放的基地址。



例子：已知GDTR=0E003F0003FFH，则全局描述符表的基址是多少？这个全局描述符表有多大，里面有多少个描述符？

• GDT的地址为0E003F00H

• 长度为3FFH+1=400H。

• 可容纳400H/8=80H个段描述符。

#### 中断描述符表寄存器

• 中断描述符表寄存器（Interrupt Descriptor Table Register，IDTR）也在存储器中定义了一个表，该表称为中断描述符表IDT。

• IDT中保存的不是段描述符，而是中断门描述符。每个门描述符也包含8字节

• IDT最多包含256个门描述符，因为CPU最多支持256个中断。中断门指向的是中断服务程序的入口。

• IDTR是48位的寄存器。其最低16位是限长，给出IDT的字节大小（其值比IDT的长度少1），其高32位是线性地址，经过分页部件转换为物理地址，指出IDT在物理存储器中存放的基地址。

• 保护模式下的中断描述符表IDT的位置是可变的，实模式下的中断向量表的地址是固定在物理地址00000H处。

• GDTR和IDTR的值必须在进入保护模式之前装入。在实模式下执行LGDT和LIDT指令装入GDTR和IDTR。



例子：

已知IDTR=0E003F40007FFH，则中断描述符表的基址是多少？这个中断描述符表有多大，里面有多少个描述符？

• IDT的地址为0E003F400H

• 长度为7FFH+1=800H

• 可容纳800H/8=100H个描述符。

#### 局部描述符表寄存器

• 保护模式提供了多任务的环境，为每个任务建一个局部描述符表（Local Descriptor Table，LDT）。

• LDT只含有与系统中某一个任务相关的各个段的描述符。

• 可以使每一任务的代码段、数据段、堆栈段与系统其他部分隔离开。

![image-20230104100121846](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104100121846.png)

• ①和②步由GDTR确定了GDT表在存储器中的位置和限长。LDTR中是一个选择符，它包含了LDT描述符在GDT中的索引。③步是依据LDTR在GDT中取出LDT描述符的过程。在LDT描述符中，包含由LDT的位置和限长，即④和⑤步

#### 任务寄存器

• 任务寄存器（Task Register，TR）在保护模式的任务切换机制中使用。TR是16位的选择符，其内容为索引值，它选中的是TSS描述符。TR的初值由软件装入，当执行任务切换指令时TR的内容自动修改。

• 在多任务环境下，每个任务都有属于自己的任务状态段（Task Status Segment，TSS），TSS中包含启动任务所必需的信息。

• 任务状态段TSS在存储器的基地址和限长（大小）由TSS描述符指出。TSS描述符放在全局描述符表GDT中，TR内容为选择符，它指出了TSS描述符在GDT中的顺序号。

![image-20230104100359454](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104100359454.png)

• ①和②步由GDTR确定了GDT表在存储器中的位置和限长。TR是一个选择符，这个选择符中包含了TSS描述符在GDT中的索引。③步依据TR在GDT中取出TSS描述符。在第④和⑤步中，在TSS描述符中取得TSS的基址和限长。



例子：

假定全局描述符表的基址为00011000H，TR为2108H，问TSS描述符的起止范围是多少？

• TSS起始地址=00011000H+2108H=00013108H

• TSS终止位置=00013108H+7H=0001310FH



### 内存管理

• 实模式下分段管理

• 20位地址总线，最大可寻址内存空间应为2 20=1MB，其物理地址范围从00000H～FFFFFH。

• 段的大小可以变化，16位CPU中最大的段为2 16=64KB。段的起始地址可以在任何16的倍数上，段寄存器中存放段基址除以16得到的商（也就是20位段基址的高16位）。

• 段基址:偏移量

• 10H×段基址+偏移量



![image-20230104101131812](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104101131812.png)

例子：

• 计算实模式下1000:1F00、11F0:0000、1080:1700的物理地址。

• 1000:1F00=10H×1000+1F00=11F00H；

• 11F0:0000=10H×11F0+0000=11F00H；

• 1080:1700=10H×1080+1700=11F00H。

#### 保护模式下分段管理

• 保护模式下，逻辑地址同样由段基址:偏移量的格式形成，只不过，原来用来存储段基址的段寄存器不再表示段的起始位置，而是用来表示段选择符。

• 该地址表示形式称为虚拟地址，对应的地址空间称为虚拟地址空间。

• 以CS:EIP为例， CS中存放了一个16位的段选择符，EIP是32位偏移量。16位段选择符加上32位偏移量，总共是48位，其中段选择符的2位RPL与虚拟地址的转换无关，因此可以认为虚拟地址是46位的，段选择符的Index和TI占14位，偏移量为32位，虚拟地址空间为2<sup>46</sup>B=64TB

![image-20230104130256342](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104130256342.png)

#### 段描述符

• 段描述符用于描述代码段、数据段和堆栈段。

• 段描述符位于GDT或LDT中，占8字节（64位），包括：段基址（32位）、限长（20位）、访问权限（8位）和属性（4位）。

![image-20230104131528752](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104131528752.png)

![image-20230104131612348](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104131612348.png)

• P（Present）：存在位。P＝1时表示该段己装入内存；P＝0时表示该段没有在内存中，此时访问该段会产生段异常。操作系统将某个段从物理内存中交换到磁盘时，设置此位为0。

• DPL（Descriptor Privilege Level）：描述符特权级，说明该段的特权级，取值为0～3。

• S（System）：描述符类型位，S=1时，这个段为代码段、数据段或堆栈段；S=0时，为系统段描述符。

• E（Executable）：可执行位，用来区分代码段和数据段。S=1且E=1时，这是一个代码段，可执行。S=1且E=0时，这是一个数据段或堆栈段，不可执行。E=0时，后面的两位为ED和W；若E=1时，后面的两位为C和R。• ED（Expansion Direction）：扩展方向位（对数据段或堆栈段）。ED=0时，段向上扩展（从低地址向高地址扩展），偏移量小于等于限长。ED=1时，段向下扩展（从高地址向低地址扩展），偏移量必须大于限长。限长是指地址上限。一般情况下ED位为0。

• W（Writeable）：写允许位（对数据段或堆栈段）。W=0时，不允许对这个数据段写入；W=1时，允许对这个数据段写入。

• C（Conforming）：一致位（对代码段）。C=0时，这个段不是一致代码段；C=1时，这个段是一致代码段。一致代码段就是操作系统拿出来被共享的代码段，这些代码段允许被低特权级的用户直接调用访问。

• 此时特权级高的程序不允许访问特权级低的代码，即核心态不允许调用用户态的代码；特权级低的程序可以访问到特权级高的代码，但是特权级不会改变。

• 除了一致代码段外，其他的代码段称为非一致代码段。非一致代码段常用于那些为了避免低特权级的访问而被操作系统保护起来的系统代码。非一致代码段只允许特权级相同的程序间访问，绝对禁止不同级访问，即核心态不使用用户态，用户态也不使用核心态。

• R（Readable）：读允许位（对代码段）。R=0时，不允许读这个段的内容；R=1时，允许读这个段的内容。对代码段进行写操作总是被禁止的。

• A（Accessed）：访问位。A＝1表示段己被访问（使用）过；A＝0表示段未被访问过。操作系统利用这个位对段进行使用统计，可以将那些很长时间没有被访问过的段从内存中调出，释放其内存给其他程序所使用。

• G（Granularity）：粒度。G＝1时，限长以页为单位；G＝0时，限长以字节为单位。

• D（Default Operation Size）：默认操作数宽度。D＝1时，为32位数据操作段；D＝0时，为16位数据操作段。• 限长位在描述符中一共占2位。G＝1时，限长的内容加上1后就是段所占的页数，1页的大小为2<sup>12</sup>＝4KB；G＝0时，段限长以字节为单位，限长的内容+1就是段所占的字节数。

• G＝1，限长位为FFFFFH时，段所占的页数是FFFFFH+1=100000H，即2<sup>20</sup>页，段的大小为2<sup>32</sup>=4GB，有效偏移量的范围是00000000H～FFFFFFFFH。G＝0，限长位为FFFFFH时，段的大小为2<sup>20</sup>=1MB，有效偏移量的范围是00000000H～000FFFFFH。



例子：设段基址为0CD310000H，段界限为001FFH。G位分别为0和为1时，求段的起始地址和段的结束地址。

• 段的起始地址=段基址=0CD310000H

• （G=0）段的结束地址=段基址+段限长=0CD310000H+001FFH=0CD3101FFH

• （G=1）段的结束地址=段基址+段限长=0CD310000H+(001FFH+1)×4K−1=0CD50FFFFH

#### 段描述符高速缓存

• 如果每一次都需要到内存中去读取段描述符，那么CPU的运行效率就会极大地降低。为解决这个问题，CPU在内部设置了段描述符高速缓存。段描述符高速缓存总是与CS、DS、ES、SS、FS、GS段寄存器和描述符的当前值保持一致，只有段寄存器的值发生改变时，才需要到GDT或LDT中装入段描述符。

• 这些缓存器是不可见的

#### 段式地址转换

![image-20230104131930282](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104131930282.png)

#### 页式内存管理

• 每一个任务都有它自己的一个线性地址空间，由于线性地址是32位的，所以线性地址空间为2 32=4GB。分段管理时，段的长度不固定，段和段之间也允许重叠；而页面的划分则严格得多。所有页的长度固定，页与页之间也没有重叠。

• 页面大小为4KB，则32位CPU将4GB的线性地址空间划分成2<sup>20</sup>页。

• 分页机制就是一种将线性地址的页面映射到物理地址页面的手段，也就是从线性地址到物理地址的转换过程。分页机制中用到了两个表：页目录表和页表。

• 32位线性地址被划分为3个部分：页目录索引（10位），页表索引（10位），页面字节索引（12位），其中第1项是对页目录（Page Directory）的索引，第2项是对页表（Page Tables）的索引，第3项是线性地址在页面（Page Frame）内的偏移。

![image-20230104132027204](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104132027204.png)

![image-20230104134309930](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104134309930.png)

• ①：页目录的地址由CR3的最高20位决定，CR3又被称做页目录基址寄存器PDBR（Page Directory Base Register），CR3的低12位＝000H。页目录的大小为4KB，由1024个页表描述符组成，每个页表描述符占4个字节。

• ②：线性地址中高10位为页目录索引，页目录基地址加上页目录索引乘以4获得的地址指向页目录表中一个页表描述符。

• ③：页表描述符的高20位给出了页表的基地址。页表同样占4KB，由1024个页描述符组成，每个页描述符占4字节。• ④：线性地址中的页表索引（10位），指示了被访问的页在页表中的序号。根据页表基地址加上10位页表索引乘以4指向页表中的一个页描述符。

• ⑤：页描述符的高20位给出了物理页面的基地址的高位20位。

• ⑥：物理页面的基地址再加上线性地址中12位字节的页内偏移量，得到物理地址。

• 片内转换检测缓冲器（32个页描述符）

#### 页表项

• 页目录表、页表和页面的基地址的低12位全部为0，定位在页的边界上。

• 页表项的低12位提供保护功能和统计信息。U/S位、R/W位、P位实现页保护机制；D位和A位提供统计信息。

![image-20230104135716846](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104135716846.png)

• U/S（User/Supervisor）：用户/管理员位。U/S=0时，只有操作系程序可以访问该页，不允许用户程序访问，这可以保护操作系统使用的页面不被用户程序破坏（读写）；U/S=1时，允许用户程序访问该页。

• R/W（Read/Write）：读写位。R/W＝0，用户程序对页面只有读限，不能写入；R/W＝1时，可读/写。不论R/W位设置如何，操作系统的程序都可以对页面进行读写。

• P（Present）：存在位。P=1，页表或页存在于物理内存中；P=0，页表或页不在物理内存中。如果内存不足时，操作系统会选择那些使用频率低的页面，设置它们的P位为0，将这些物理页面释放出来供其他程序使用。产生缺页异常时，程序中使用的32位线性地址被保存在CR2中。

• A（Accessed）：访问标志。如果对某页表或页访问过，CPU设置页表项中的A位为1。操作系统定期扫描该项，统计使用次数。当需要调出（释放）页面时，操作系统一般选择那些最少使用的或长期不用的页。

• D（Dirty）：写入位。D=1时表示对该页进行过写操作，D=0时表示对该页还没有进行过写操作。D位只用于页描述符，它是写入标志。当需要释放某个物理页面时，若其D=0表示磁盘中交换页面的内容和物理页面的内容一致，不需要向磁盘重写；若D=1则需要将这个页面写到磁盘

![image-20230104135816485](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104135816485.png)

• 一个物理页存在两级保护属性，一个是页表描述符中的保护属性，另一个是页描述符中的保护属性。在两级保护属性不一致的情况下，CPU从二者中取一个较严格的保护权限。例如，页表描述符的属性R/W＝0（只读），页描述符的属性R/W＝1（可读写），则最后结果是R/W＝0（只读）。

![image-20230104143312508](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104143312508.png)

![image-20230104143452809](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104143452809.png)

### 任务

• 在保护模式下每个任务是独立的，CPU提供了实现任务间快速切换的高效机制。在任何时刻都有一个当前任务，由TR寄存器指定，CPU在这个任务的环境下执行。当运行一个应用程序后，操作系统就为这个程序创建一个任务。

• 每个任务都由两个部分组成：任务执行环境（Task ExecutationSpace）和任务状态段TSS（Task State Segment）。

#### 任务执行环境

• 任务执行环境包括一个代码段、堆栈段和数据段等，任务在每一个特权级上执行时都有一个堆栈段。

• 每个任务都有一个LDT描述符表，构成一个局部地址空间，局部空间的数据和代码不能被其他任务访问。

![image-20230104145231709](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104145231709.png)

#### 任务状态段

• 任务状态段TSS（Task State Segment）中保存了任务的各种状态信息。它在任务切换过程中起着重要作用，通过它可以实现任务的挂起和恢复。

• 在任务切换过程中，首先CPU中各寄存器的当前值被自动保存到TR所指定的TSS（当前任务状态段）中；然后下一任务的TSS的选择符被装入TR；最后从TR所指定的TSS中取出各寄存器的值送到处理器的各寄存器中。

• 任务状态段在主存中的位置、大小和属性等信息由任务状态段描述符（即TSS描述符）来描述。TSS描述符属于系统描述符，S位等于0，它必须放在GDT表中，而不能放在LDT或IDT中。

• 在任务切换或执行LTR指令时，会将新的任务状态段选择符装载到TR寄存器。

![image-20230104145324907](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104145324907.png)

• TSS的基本格式由104字节（000H～067H）组成。这104字节的基本格式是不可改变的，在此之外系统软件还可在TSS段中定义若干附加信息。基本的104字节可分为寄存器保存区域、内层堆栈指针区域、地址映射寄存器区域、域链接字段区域、I/O许可位图等。

• LDTR和CR3的值与特定任务相关，随着任务的切换，LDTR和CR3的值也要切换。TSS中保存了该任务的CR3和LDTR。

• 链接字段位于在TSS偏移0开始的双字中，其高16位未用，而低16位保存前一任务的TSS的选择符。如果当前的任务由段间调用指令CALL、中断/异常而激活，那么当前任务TSS中的链接字段保存被挂起任务的TSS的选择符，并且标志寄存器EFLAGS中的NT位被置为1，表示嵌套。

• I/O许可位图区域是为了实现输入/输出的保护。I/O许可位图作为TSS的扩展部分，TSS内偏移66H处的字用于存放I/O许可位图在TSS内的偏移（从TSS的头开始计算）。

### 门

• 4种：调用门、任务门、中断门、陷阱门

• 调用门用于控制传送，来改变任务或者程序的特权级别；任务门像个开关一样，用来执行任务切换；中断门和陷阱门用来指出中断服务程序的入口地址。

• 门描述符属于系统描述符

#### 门描述符

![image-20230104145554410](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104145554410.png)

• 系统描述符中设置了一个类型（TYPE）字段，4位可表示16种类型 

![image-20230104145622066](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104145622066.png)

#### 调用门

• 调用门可以实现当前任务从低特权级到更高特权级的间接控制转移，它在更高级特权级的段中定义了一个入口点，该入口点的虚拟地址（目标选择符和偏移量）包含在调用门中。

• 调用门可以驻留在GDT中，也可以驻留在LDT中，但是不可在IDT中。

• 参数计数值表示有多少个（最多31个）参数必须从主程序（低特权级代码段）的堆栈复制到被调用子程序（高特权级代码段）的堆栈。将它乘以4后（32位系统）或者乘2（16位系统），得到参数在堆栈中的字节数。其他门描述符的参数计数值无意义。



**使用调用门进行段间调用操作过程**

![image-20230104145704901](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104145704901.png)

• 调用指令“CALL X:Y”指令中虚拟地址X:Y，其中X是一个选择符，由它指向了一个调用门描述符（第①步），而Y的值不起作用。

• 调用门描述符中的选择符指向了一个段描述符（第②步），段描述符指出了被调用段的段基址（第③步），而入口点的偏移量就是门描述符中的偏移量（第④步），决定了调用哪一个代码段以及子程序在代码段中的偏移。

• 这种形式的CALL指令可以通过调用门转移到更高的特权级，在更高的特权级下执行所调用的子程序，子程序执行完毕后，由RET指令返回CALL指令所在的较低级别的程序。

#### 任务门

• 任务门内的选择符必须指示GDT中的任务状态段TSS描述符，门中的偏移量无意义。任务的入口点保存在TSS中。利用段间转移指令JMP和段间调用指令CALL，通过任务门可实现任务切换。

![image-20230104145754719](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104145754719.png)

#### 中断门和陷阱门

• 中断门和陷阱门描述中断/异常处理程序的入口点

• 中断门和陷阱门内的选择符必须指向代码段描述符，门内的偏移就是对应代码段的入口点的偏移。

• 中断门和陷阱门只有在中断描述符表IDT中才有效。

### 任务切换

#### 任务切换的场景

• 当前的程序、任务、过程执行远程JMP或者CALL指令，选择了GDT中的TSS描述符，此时指令中的偏移量忽略。

• 当前的程序、任务、过程执行远程JMP或者CALL指令，从GDT或者LDT中选择了任务门，目标地址的偏移量部分被忽略，新的TSS选择符在门中。

• 发生了中断或异常，中断向量选择了IDT中的任务门。新TSS选择符在门中。

• 当FLAGS中的NT=1时，执行IRET指令，目的任务选择符在执行IRET任务的TSS链接域中。

#### 直接任务切换

![image-20230104152636315](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104152636315.png)

#### 间接任务切换

• 间接任务切换通过任务门来完成。利用段间转移指令JMP和段间调用指令CALL，通过任务门可实现任务切换。

• 任务的入口点保存在TSS中。

![image-20230104152652506](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104152652506.png)

• 间接任务切换时，指令中的段寄存器内容为任务门描述符。

• 当使用JMP/CALL X:Y指令时，由X指向一个任务门描述符去查找GDT或者LDT；为中断响应时查找IDT，获得任务门。取出任务门中的TSS选择符，去GDT中查找获得新TSS描述符。注意新TSS的B位必须为0。

• JMP或CALL指令内的偏移（Y）没有被使用。

• 任务门的DPL（DPLGATE）规定了访问该任务门的最低特权级，只有在同级或更高级别的程序中才可以访问它。即DPLGATE≥MAX（CPL，RPL），RPL是任务门选择符X的最后2位。

#### 任务切换步骤

• ①特权级检查；

• ②是否存在内存和限长检查；

• ③更新TR，并保存旧的TSS动态部分；

• ④加载TR，使新任务B=1，加载任务中各种寄存器内容。当CR0中TS被置位时表示任务切换完毕。

#### 任务内特权级变化时堆栈指针的使用

• 通过调用门向高特权级转移

• 只有在特权级变化时，才会切换堆栈。

• TSS中包含有指向0级、1级和2级堆栈的指针。（为什么？）

• 还有SS和ESP

• 在特权级提升时，根据新的特权级使用TSS中相应的堆栈指针对SS及ESP寄存器进行初始化，建立起一个空栈。再把低特权级程序的SS及ESP寄存器的值压入堆栈，以使得相应的返回指令可恢复原来的堆栈。（为什么？）

• 原特权级无法直接获取• 从低特权级堆栈复制以双字为单位的调用参数到高特权级堆栈中，调用门中的CNT字段值决定了参数的个数。

• 通过复制栈中的参数，使高特权级的子程序可以访问主程序传递过来的参数。

• 与使用CALL指令通过调用门向高特权级转移相反，使用RET指令实现向低特权级转移。段间返回指令RETF从堆栈中弹出返回地址。

• 段间返回指令RETF从堆栈中弹出返回地址（CS:EIP）。选择符的RPL确定返回后的特权级。

• RET指令所使用的返回地址的选择符只能是代码段描述符，而不能是系统描述符或门描述符。与CALL指令不能向低特权级转移相对应，RET指令不能向高特权级转移。

### 保护

• 对数据的保护

• 对程序的保护

• 对输入输出的保护

#### 数据访问保护

• 类型检查。装入CS时，段描述符中的E位必须为1，标记为可执行的段；装入DS、SS等寄存器时，E位必须为0。数据段描述符的W位为0时，不能对数据段进行写操作。代码段描述符的R位为0时，不能对代码段进行读操作。

• 限长检查

• 其他属性检查。主要是P位（存在位）

#### 特权级检查

• DPL≥MAX（CPL，RPL），即程序只能访问特权级相同或者较低的数据

![image-20230104153205812](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104153205812.png)

• 给SS赋值时，除了要满足DPL≥MAX（CPL，RPL）的条件之外，还必须满足RPL=CPL。也就是说SS的RPL总是等于当前执行程序的CPL。

#### 转移

##### 直接转移

不涉及门，段内或者段间直接取得段描述符。



段内转移

• 在同一代码段内转移时，显然转移前后不重新加载CS，特权级不发生变化，使用普通的跳转（JMP）或调用（CALL）指令即可。这时只需要检查限长



段间转移

• 需使用远跳转或远调用指令，指令的格式如：“JMP X:Y”、“CALL X:Y”等，其中X是16位段选择符，Y是32位偏移。此时需要重新加载CS寄存器，处理器除了要检查限长以外，还要执行特权检查。

![image-20230104153349601](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104153349601.png)



##### 间接转移

• 当CPL＞DPLTSS时，就不能采用直接切换，必须通过任务门进行任务切换。

• 选择符指向的是任务门描述符，门中的TSS选择符选中新任务的TSS描述符，启动新的任务。



涉及到的特权级

• 当前特权级CPL，即JMP或CALL指令所在的程序的特权级

• 请求特权级RPL，即选择符X的最低2位

• DPLGATE，即门描述符的DPL

• DPLCODE，即目标代码段描述符的DPL

• CCODE，即目标代码段描述符的C位



**间接转移条件-使用CALL指令**

• DPLGATE≥MAX（CPL，RPL）

• DPLCODE≤CPL

• 在满足前面两条特权级要求的情况下：

• 如果CCODE为1，表示一致代码段，则当前特权级不变；

• 如果CCODE为0，则当前特权级提升为DPLCODE（DPLCODE＜CPL或者维持不变（DPLCODE＝CPL）。

![image-20230104153455466](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104153455466.png)



**间接转移条件-使用JMP指令**

• DPLGATE≥MAX（CPL，RPL）

• CCODE为1且DPLCODE≤CPL 或 CCODE为0且DPLCODE＝CPL

• JMP指令只能转移到同级的代码，而不能转移到更高的特权级。



#### 输入输出保护

• CPU采用I/O特权级IOPL（I/O Privilege Level）和TSS段中I/O许可位图的方法来控制输入/输出，实现对应用程序I/O指令的限制。

• CPL≤IOPL时，可以执行I/O敏感指令。

• 任务状态段中的I/O许可位图也影响I/O敏感指令的执行。I/O许可位图规定了I/O空间中的哪些地址可以由该任务的任何特权级程序所访问，而不受IOPL的限制。

![image-20230104153544339](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230104153544339.png)

• 当前特权级CPL比IOPL高或者相同时，可以正常执行所有I/O敏感指令；

• CPL特权级比IOPL特权级低时，执行CLI和STI指令将引起通用保护异常，而其他4条指令是否能够执行要根据访问的I/O地址及任务的I/O许可位图来决定，如果条件不满足时，那么将引起保护异常。



**I/O许可位图的保护**

• 只用IOPL来限制I/O指令的执行会使得在特权级3执行的应用程序要么可以访问所有I/O地址，要么不能访问所有I/O地址，使用很不方便。

• 在任务状态段中设置了I/O许可位图。每个任务的I/O许可位图都可以由操作系统来设置。I/O许可位图就是一个二进制位串。位串中的每一位对应一个I/O地址，位串的第0位对应I/O地址0，位串的第n位对应I/O地址n。如果位串中的第n位为0，那么I/O地址n就可以由任何特权级的程序访问，而不加限制；如果第n位为1，I/O地址n只能由在IOPL特权级或更高特权级运行的程序访问

• 如果一条I/O指令涉及多个I/O地址，例如“IN EAX, DX”涉及4个I/O地址，则在检查许可位时，这条指令用到的所有I/O地址的许可位都必须为0才允许访问。

• Intel 80x86系列计算机的I/O地址空间范围是0000H～0FFFFH，所以I/O许可位图的二进制位串最大为8KB。

• TSS内偏移66H的字确定I/O许可位图在TSS段中的位置，即I/O位图基址。I/O许可位图的大小s等于TSS段的长度减去I/O位图基址，它定义了I/O地址空间0～s×8–1的许可位。CPU认为大于或等于s×8的I/O地址许可位全部为1。

• 由于I/O许可位图最长可达8KB，所以开始偏移应小于56KB，但必须大于等于104B，因为TSS中前104字节为TSS的固定格式，用于保存任务的状态。

**对IOPL的保护**

• 只有在特权级0下执行的程序才可以修改IOPL位及VM位；只有IOPL级或更高的特权级的程序才可以修改IF位。指令POPF不能改变VM位，而PUSHF指令所压入的标志中的VM位总为0。



## Chapter 3 指令系统

• 一台计算机所拥有的全部指令的集合构成了它的指令系统。

• CPU的每一次升级都伴随着指令集的更新与扩充。

• 一条指令通常由操作码域和操作数域两部分组成，操作码域指示计算机要执行的操作，操作数域则提供与操作数或操作数地址有关的信息。

### 数据寻址方式

• 寻址方式分为与数据有关的寻址方式和与转移地址有关的寻址方式。
• MOV 目标, 源 ;把源操作数传送给目标
• MOV是实现数据传送功能的操作码助记符，简称为操作码。目标和源是操作数，中间用逗号隔开。注释内容从“;”开始。

#### 立即数寻址

• 操作数直接包含在指令中，紧跟在操作码之后的寻址方式称为立即寻址方式。
• MOV BL,9 ;执行结果（BL）= 9
• MOV EAX,1234H ;执行结果（EAX）= 1234H
• 只能出现在源操作数的位置

#### 寄存器寻址方式 

• 操作数直接包含在寄存器中，由指令指定寄存器的寻址方式。

• 寄存器可以是通用寄存器，包括8位、16位、32位通用寄存器。 也可以是段寄存器，但目标寄存器不能是CS。 

• MOV ECX, 9AH 

• MOV BX, AX 

• 速度快，数量少，个别操作受限制，比如段寄存器。

#### 直接寻址方式 

• 从这个寻址方式开始，操作数位于存储器中。 

• 操作数的有效地址Effective Address（EA）直接包含在指令中的寻址方式称为直接寻址方式。

![image-20230112154055457](C:\Users\Administrator\Desktop\github repo\Learing_note\image\汇编\image-20230112154055457.png)

• MOV EAX, [00404011H]
• [00404011H]是直接寻址方式的一种表示形式。
• 注意这里的00404011H用[ ]括起来，它是一个普通变量的有效地址，而不是操作数本身。
• MOV EAX, VAR
• VAR是一个内存变量名，它代表一个内存单元的符号地址。

##### 段超越

• 1、2、4寻址类型，可以使用段超越前缀显式地说明。段超越前缀的功能是明确指出本条指令所要寻址的内存单元在哪个段。
• 段寄存器名:存储器寻址方式。
• MOV EBX, ES: MEM

#### 寄存器间接寻址方式 

• 操作数的有效地址在寄存器而操作数本身在存储器中的寻址方式 称为寄存器间接寻址方式。 

• 对于16位寻址，这个寄存器只能是基址寄存器BX、BP或变址寄存 器SI、DI；对于32位寻址，允许使用任何32位通用寄存器。 

• 指令中使用的是BX、SI、DI、EAX、EBX、ECX、EDX、ESI、EDI， 则默认操作数在数据段，即它们默认与DS段寄存器配合；若使用 的是BP、EBP、ESP，则默认操作数在堆栈段，即它们默认与SS段 寄存器配合。

• MOV AL, [BX] 

• 运行在实模式下，若（DS）= 3000H，（BX）= 78H，（30078H） = 12H，则物理地址 = 10H ×（DS）+（BX）= 30078H，该指令 的执行结果是（AL）= 12H。 

• MOV AX, [BP] 

• 运行在实模式下，若（SS）= 2000H, （BP）= 80H，（20080H） = 12H，（20081H）= 56H，则物理地址= 10H ×（SS）+（BP） = 20080H，该指令的执行结果是（AX）= 5612H。

#### 寄存器相对寻址方式

• 操作数的有效地址是一个寄存器的内容和指令中给定的一个位移量（disp）之和。

• 对于16位寻址，这个寄存器只能是基址寄存器BX、BP或变址寄存器SI、DI；对于32位寻址，允许使用任何32位通用寄存器。

• 位移量可以是8位、16位、32位（只适用于32位寻址情况）的带符号数。

• 与段寄存器的配合情况同寄存器间接寻址方式。

• 使用BP、EBP、ESP，则默认与SS段寄存器配合；使用其他通用寄存器，则默认与DS段寄存器配合。

• 允许使用段超越前缀。

• MOV AL, 8[BX] ;8是位移量

• 也可以表示为：MOV AL, [BX+8]

• 实模式下，若（DS）= 3000H，（BX）= 70H，（30078H）= 12H

• 则物理地址=10H ×（DS）+（BX）+ 8 = 30078H，该指令的执行结是（AL）= 12H。

• 使用这种寻址方式可以访问一维数组。

• 其中，TABLE是数组起始地址的偏移量（即数组名），寄存器中是数元素的下标乘以元素的长度（一个元素占用的字节数）

• 下标从0开始计数。

#### 基址变址寻址方式

• 对于16位寻址，操作数的有效地址是一个基址寄存器（BX、BP）和一个变址寄存器（SI、DI）的内容之和。

• 对于32位寻址，允许使用变址部分除ESP以外的任何两个32位通用寄存器的组合。

• 默认使用段寄存器的情况由所选用的基址寄存器决定。若使用BP、ESP或EBP，默认与SS配合；若使用BX或其他32位通用寄存器（386以上），则默认与DS配合。

• 允许使用段超越前缀。

• EA =（基址寄存器）+（变址寄存器）

• MOV AL, [BX][SI] / MOV AL, [BX+SI]

• MOV EAX, [ EBX ] [ ESI ]

#### 相对基址变址寻址方式

• 对于16位寻址，操作数的有效地址是一个基址（BX、BP）和一个变址寄存器（SI、DI）的内容和指令中给定的一个位移量（disp）之和。

• 对于32位寻址，允许使用变址部分除ESP以外的任何两个32位通用寄存器及一个位移量的组合。

• 默认段寄存器与基址变址寻址方式相同。

• 可以访问形如ARY[3][2]的二维数组

• MOV AL, ARY[BX] [SI] / MOV AL, ARY [BX+SI]

• MOV EAX, ARY[EBX] [ESI]

#### 比例变址寻址方式

• 80386以上的微处理器才提供的

• 基址部分（8个32位通用寄存器）、变址部分（除ESP以外的32位通用寄存器）乘以比例因子、位移量（disp）。比例因子可以是1（默认值）、2、4或8

• 位移量可以是8位、32位的带符号数。

• 默认使用段寄存器的情况由所选用的基址寄存器决定。若使用ESP或EBP，默认与SS配合；若使用其他32位通用寄存器，默认与DS配合。

• 允许使用段超越前缀。

• 有效地址EA=（基址寄存器）+（变址寄存器）× 比例因子 + disp

• MOV EAX, ARY[EBX] [ESI] ;（DS:[ARY+EBX+ESI]）→ EAX

• MOV ECX,[EAX+2* EDX] ;（DS:[EAX+2* EDX]）→ ECX

• MOV EBX,[EBP+ECX* 4+10H] ;（SS:[EBP+ECX* 4+10H]）→ EBX

• MOV EDX, ES:ARY[4* EBX] ;（ES:[ARY+4* EBX]）→ EDX

### 数据运算指令

#### MOV

• 数据传送指令

• 数据传送指令可以实现数据、地址、标志的传送。除了目标地址为标志寄存器的传送指令外，其他指令不影响标志。

• 格式：MOV DST, SRC

• 功能：SRC（源）→DST（目标）

• 源操作数和目标操作数的数据类型，即应同为字节、字或双字型数据。

• 立即数不能作为目标操作数；立即数不能直接送段寄存器；目标寄存器不能是CS

• 两个段寄存器间不能直接传送；

• 两个存储单元之间不能直接传送。

**例子**

• MOV AL, 5

• MOV BL, 'A' ;  字符A的ASCII码41H送BL

• MOV AX, BX

• MOV BP, DS

• MOV DS, AX

• MOV [EBX], EAX

• MOV ES:VAR, 12

• MOV WORD PTR [EBX], 12

• MOV EAX, EBX

• MOV DWORD PTR [EBX], 12

• “DWORD PTR”，它明确指出EBX所指向的内存单元为双字型

• 要生成8 / 16位的二进制数，则需要用“BYTE PTR / WORD PTR”

**对错**
• MOV 1000H, EAX; 错误原因：立即数作为目标操作数

• MOV DS, 1000H ; 错误原因：立即数直接送段寄存器

• MOV VAR, [EBX] ; 错误原因：两个存储单元之间直接传送

• MOV CS, AX ; 错误原因：目标寄存器是CS

• MOV ES, DS ; 错误原因：两个段寄存器间直接传送



**借助于FFSET和SEG操作符，实现地址传送**

• MOV AX, SEG TAB ;把TAB的段基址送给AX寄存器

• MOV DI, OFFSET TAB ;把TAB的偏移量送给DI寄存器

##### MOVSX

带符号扩展的数据传送指令

• MOVSX指令只有80386以上CPU提供。

• 格式：MOVSX DST, SRC

• 功能：SRC→DST，DST空出的位用SRC的符号位填充。

• 说明：DST必须是16位或32位寄存器操作数，SRC可以是8位或16位的寄存器或存储器操作数，但不能是立即数。

• MOV DL, 98H

• MOVSX AX, DL ;AX中得到98H的带符号扩展值0FF98H

• MOV CX, 1234H

• MOVSX EAX, CX ;EAX中得到1234H的带符号扩展值00001234H

• MOV VAR, 56H

• MOVSX AX, VAR ;AX 中得到56H的带符号扩展值0056H

##### MOVZX

带零扩展的数据传送指令

• MOVZX指令只有80386以上CPU提供。

• 格式：MOVZX DST,SRC

• 功能：SRC→DST，DST空出的位用0填充。

• 说明：DST必须是16位或32位寄存器操作数；SRC可以是8位或16位的寄存器或存储器操作数，但不能是立即数。

• MOV DL, 98H

• MOVZX AX, DL ;AX中得到98H的带零扩展值0098H

• MOV CX, 1234H

• MOVZX EAX, CX ;EAX中得到1234H的带零扩展值00001234H

• MOV VAR, 56H

• MOVZX AX, VAR ;AX 中得到56H的带零扩展值0056H

堆栈操作指令

## Chapter 4 汇编语言程序开发



## Chapter 5 子程序设计

## Chapter 6 存储系统与技术

## Chapter 7 总线技术

## Chapter 8 接口技术

## Chapter 9 中断技术


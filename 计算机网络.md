# 计算机网络学习笔记

## Cjapter 0 基本概念

### 0.2 数据链路层

链路(link)：一条无源的点到点的物理线路段，中间没有任何其他的交换结点。

数据链路(data link) ：协议＋链路。

结点（node）：网络中的主机（host）、交换机和路由器（router）称为结点

端到端（end to end）：从源结点（source node）到目的结点（destination node）的通信称为端到端通信，通信路径（path）可能由多个链路组成。

点到点（point to point）：在相邻结点间的一条链路上的通信称为点到点通信。

**信道利用率与信道吞吐率：**

一般情况下，

信道带宽b比特/秒，帧长度L比特，往返时延R秒，

则信道利用率为

**(L/b) / (L/b + R) = L / (L + Rb)**

结论

往返时延大，信道带宽高，帧短时，信道利用率低。

![image-20221224105822232](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224105822232.png)



## Chapter 1 计算机网络体系结构

### 1.1 计算机网络的概念、组成与功能

### 1.2 计算机网络的分类

### 1.3 计算机网络的分层结构

### 1.4 计算机网络协议、接口、服务等概念

### 1.5 ISO/OSI参考模型和TCP/IP模型

## Chapter 2 物理层

不考

## Chapter 3 数据链路层

### 3.1 数据链路层的功能

为网络层提供服务

1.无确认的无连接的服务

2.有确认的无连接的服务

3.有确认的面向连接的服务

### 3.2 差错控制

差错：接收的数据与发送的数据不一致

随机差错：具有独立性，与前后码元无关

突发差错：相邻多个数据位出错



差错产生的原因：通信信道的噪声

热噪声：由传输介质导体的电子热运动产生，幅度较小，是产生随机差错的主要根源。

冲击噪声：由外界电磁干扰产生，幅度较大，是产生突发差错的主要根源。

冲击噪声是引起差错的主要原因



差错评价指标：

![image-20221224092314962](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224092314962.png)



差错控制的基本方式：



1.反馈纠错

在接收端能发现差错，但不能确定错码的位置，通过反馈信息请求发送端重发，直到接收端肯定确认为止。适用于双工通信和非实时通信系统。

2.前向纠错

在接收端不仅能发现错码，而且还能确定错码的位置，并纠正错误。适用于单工通信和实时通信系统。

3.混合纠错

少量差错在接收端自动纠正，若超出自行纠正能力时，通过反馈信息请求发送端重发。



**误码控制基本原理**

![image-20221224092418675](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224092418675.png)



**<font color = 'red'>码字的检错与纠错能力</font>**

码字（n位）=数据码（m位）+冗余码（r位）

海明距离：两个码字之间对应码元位的不同码元的个数。

![image-20221224092810232](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224092810232.png)

![image-20221224092931741](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224092931741.png)

![image-20221224092946669](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224092946669.png)

**注意**:码字集合的海明距离是任意两个元素**最小**的海明距离



**误码控制编码的分类**：
![image-20221224093138025](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224093138025.png)

**纠错检错的常用方法**：
![image-20221224093200786](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224093200786.png)

#### 3.2.1 检错编码

**<font color = 'red'>循环冗余码</font>**

**我对计算步骤的总结:**

发送方计算步骤：

1. 将数据码后面补齐r个零
2. 用数据码除以生成多项式，得到r位的余数
3. 将数据码作为数据位，r位余数作为校验位 发送

接收方计算步骤：

1. 将接收到的二进制码直接除以生成多项式
2. 如果余数为0，则没有误码，否则误码

![image-20221224093804810](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224093804810.png)

![image-20221224094655506](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224094655506.png)

![image-20221224094709841](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224094709841.png)

![image-20221224094720723](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224094720723.png)

例子：

![image-20221224094735310](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224094735310.png)

![image-20221224094745471](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224094745471.png)

![image-20221224094757870](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224094757870.png)

![image-20221224094811629](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224094811629.png)

#### 3.2.2 纠错编码

**<font color = 'red'>海明码</font>**

海明码计算步骤：

发送方：

1.确定海明码的位数

设n为有效信息的位数，k为校验位的位数，则信息位n和校验位k应满足

n+k≤2<sup>k</sup>-1

(若要检测两位错，则需再增加1位校验位，即k+1位)

2.确定校验位的分布

规定校验位P<sub>i</sub>在海明位号为2<sup>i-1</sup>的位置上，其余各位为信息位。

3.计算校验位：

将所有数据为1的数据位位号做异或运算，得到的结果按从高到低填入校验位

4.发送



接收方：

将接收到的数据为1的位号进行异或运算，如果得到的结果为0，则无差错，如果得到的结果不为零，则错误指向计算出来的二进制数值对应的位号。



![image-20221224093711922](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224093711922.png)

![image-20221224093727815](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224093727815.png)

### 3.3 流量控制与可靠传输机制

流量控制涉及对链路上的帧的发送速率的控制，以使接收方有足够的缓冲空间来接收每个帧。

数据链路层的可靠传输通常使用确认和超时重传两种机制来完成。

![image-20221224110406706](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224110406706.png)

![image-20221224110420705](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224110420705.png)

**信道利用率与信道吞吐率：**

一般情况下，

信道带宽b比特/秒，帧长度L比特，往返时延R秒，

则信道利用率为

**(L/b) / (L/b + R) = L / (L + Rb)**

结论

往返时延大，信道带宽高，帧短时，信道利用率低。

![image-20221224105822232](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224105822232.png)



#### 3.3.1 流量控制、可靠传输和滑轮窗口机制

滑动窗口：

在任意时刻，发送方都维持一组连续的允许发送的帧的序号，称为发送窗口：同时接收方也维持一组连续的允许接收帧的序号，称为接收窗口。发送窗口用来对发送方进行流量控制，而发送窗口的大小Wr代表在还未收到对方确认信息的情况下发送方最多还可以发送多少个数据帧。
同理，在接收端设置接收窗口是为了控制可以接收哪些数据帧和不可以接收哪些帧。在接收方，
只有收到的数据帧的序号落入接收窗口内时，才允许将该数据帧收下。若接收到的数据帧落在接收窗口之外，则一律将其丢弃。

发送端每收到一个确认帧，发送窗口就向前滑动一个帧的位置，当发送窗口内没有可以发送的帧(即窗口内的帧全部是已发送但未收到确认的帧)时，发送方就会停止发送，直到收到接收方发送的确认帧使窗口移动，窗口内有可以发送的帧后，才开始继续发送。
接收端收到数据帧后，将窗口向前移一个位置，并发回确认帧，若收到的数据帧落在接收窗口之外，则一律丢弃。

滑动窗口有以下重要特性；
1)只有接收窗口向前滑动(同时接收方发送了确认帧)时，发送窗口才有可能(只有发送方收到确认帧后才一定)向前滑动。
2)从滑动窗口的概念看，停止-等待协议、后退N帧协议和选择重传协议只在发送窗口大小与接收窗口大小上有所差别：

停正-等待协议：发送窗口大小=1,接收窗口大小=1。
后退N帧协议：发送窗口大小≥1,接收窗口大小=1。
选择重传协议，发送窗口大小>1,接收窗口大小>1。

3)接收窗口的大小为1时，可保证帧的有序接收。
4)数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的**(注意与第5章传输层的滑动窗口协议的区别)**。



#### 3.3.2 停止-等待协议

![image-20221224102546572](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224102546572.png)

#### 3.3.3 后退N帧协议



后退N帧协议的**接收窗口为1**,可以保证按序接收数据帧。

若采用n比特对帧编号，

则其发送窗口的尺寸W应满足**1≤Wr≤2<sup>n</sup>-1**。

若发送窗口的尺寸大于2<sup>n</sup>-1,则会造成接收方无法分辨新帧和旧帧。



后退N帧协议一方面因连续发送数据帧而提高了信道的利用率，另一方面在重传时又必须把原来已传送正确的数据帧进行重传(仅因这些数据帧的前面有一个数据帧出了错),这种做法又使传送效率降低。

由此可见，若信道的传输质量很差导致误码率较大时，

后退N帧协议不一定优于停止-等待协议。



GBN的两种实现方式：
![image-20221224102411679](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224102411679.png)

![image-20221224102423342](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224102423342.png)

#### 3.3.4 选择重传协议

若采用n比特对帧编号，为了保证接收方向前移动窗口后，新窗口序号与旧窗口序号没有重叠部分，需要满足条件：

**<font color = 'red'>接收窗口W<sub>R</sub>+发送窗口W<sub>T</sub>≤2"</font>**。

假定仍然采用累计确认的方法。并且接收窗口W<sub>R</sub>显然不应超过发送窗口W<sub>T</sub>(否则无意义),那么接收窗口尺寸不应超过序号范围的一半,即**<font color = 'red'>W<sub>R</sub>≤2<sup>n-1</sup></font>**。

接收窗口为最大值时，**<font color = 'red'>W<sub>Tmax</sub>=W<sub>Rmax</sub>=2<sup>(n-1)</sup></font>**。一般情况下，在SR协议中，接收窗口的大小和发送窗口的大小是相同的。

![image-20221224110224982](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221224110224982.png)

### 3.4 介质访问控制

#### 3.4.1 信道划分介质访问控制

信道划分的实质就是通过分时、分频、分码等方法把原来的一条广播信道，

逻辑上分为几条用于两个结点之间通信的互不干扰的子信道，

实际上就是把广播信道转变为点对点信道。

分为四种：

频分复用  FDM

波分复用  CDM

时分复用  TDM/STDM

码分复用  CDMA

#### 3.4.2 随机访问介质访问控制

在随机访问协议中，不采用集中控制方式解决发送信息的次序问题，所有用户能根据自己的意愿随机地发送信息，占用信道全部速率。

如果介质访问控制采用信道划分机制，那么结点之间的通信要么共享空间，要么共享时间，要么两者都共享；而如果采用随机访问控制机制，那么各结点之间的通信就可既不共享时间，也不共享空间。

所以随机介质访问控制实质上是一种将广播信道转化为点到点信道的行为



#### 3.4.2.1 纯ALOHA协议

![image-20221225103752056](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225103752056.png)

![image-20221225103818119](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225103818119.png)

![image-20221225103859681](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225103859681.png)

![image-20221225103924329](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225103924329.png)

#### 3.4.2.2 时隙ALOHA协议

![image-20221225104001784](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225104001784.png)

![image-20221225104018257](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225104018257.png)

#### 3.4.2.3 CSMA协议

![image-20221225104125892](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225104125892.png)

1. 1-persistent-CSMA

![image-20221225104227269](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225104227269.png)

2. nonpersistent-CSMA

![image-20221225104315299](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225104315299.png)

3. p-persistent-CSMA

![image-20221225104344376](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225104344376.png)



#### 3.4.2.4 CSMA/CD协议



**最小帧长=总线传播时延×数据传输速率×2**

也就是  争用期*数据传输速率



CSMA/CD的工作流程可简单概括为“先听后发，边听边发，冲突停发，随机重发”。

**CSMA/CD流程如下：**

1)适配器从网络层获得一个分组，封装成以太网帧，放入适配器的缓存，准备发送。

2)如果适配器侦听到信道空闲，那么它开始发送该帧。如果适配器侦听到信道忙，那么它持续侦听直至信道上没有信号能量，然后开始发送该帧。

3)在发送过程中，适配器持续检测信道。若一直未检测到碰撞，则顺利地把这个帧发送完毕。若检测到碰掩，则中止数据的发送，并发送一个拥塞信号，以让所有用户都知道。

4)在中止发送后，适配器就执行指数退避算法，等待一段随机时间后返回到步骤2)。



**二进制指数退避算法**

![image-20221225105618560](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225105618560.png)



相关ppt:

![image-20221225104421006](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225104421006.png)

![image-20221225104435621](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225104435621.png)

![image-20221225104502972](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225104502972.png)

![image-20221225104555674](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225104555674.png)

![image-20221225104651815](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225104651815.png)

![image-20221225104834763](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225104834763.png)

**最小帧长的计算**

![image-20221225105328860](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221225105328860.png)

例子：

对于以太网而言，争用期长51.2us，传输速率为10Mb/s，故最短帧长为64B，这个在后面经常用到。(64B-1500B)



### 3.5 局域网

#### 3.5.1 局域网的基本概念与体系结构

局域网三要素：

拓扑结构

传输介质

介质访问控制方式

![image-20221225145333791](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225145333791.png)

![image-20221225150446961](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225150446961.png)



#### 3.5.2 以太网与IEEE 802.3

![image-20221225150543180](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225150543180.png)

![image-20221225150600658](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225150600658.png)

![image-20221225150615521](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225150615521.png)

![image-20221225150634325](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225150634325.png)

![image-20221225150650520](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225150650520.png)



##### **MAC地址**

![image-20221225150723824](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225150723824.png)

![image-20221225150739299](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225150739299.png)

**<font color = 'red'>注意：对于每个字节来说，最低位优先发送！！！</font>**

![image-20221225150827481](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225150827481.png)

![image-20221225150856432](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225150856432.png)

**也就是转发异网帧，丢弃同网帧，广播未知帧**

##### **MAC帧格式**

![image-20221225151053403](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225151053403.png)

![image-20221225151107008](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225151107008.png)



![image-20221225151203816](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225151203816.png)

![image-20221225152006558](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225152006558.png)

![image-20221225152022954](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225152022954.png)



### 3.6 数据链路层设备

#### 3.6.1 网桥

![image-20221225152407730](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225152407730.png)

![image-20221225152332006](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225152332006.png)

![image-20221225152347723](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225152347723.png)

![image-20221225152858831](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225152858831.png)

![image-20221225152914586](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225152914586.png)

![image-20221225152932707](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225152932707.png)

![image-20221225153008668](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225153008668.png)

##### 透明网桥

![image-20221225153041323](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225153041323.png)

![image-20221225153112680](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225153112680.png)

##### 透明网桥逆向学习算法

![image-20221225153145909](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225153145909.png)

![image-20221225153355702](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225153355702.png)

##### 透明网桥生成树算法

![image-20221225153439931](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225153439931.png)

![image-20221225153452367](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225153452367.png)

![image-20221225153508481](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225153508481.png)

##### 源选径网桥

![image-20221225153636874](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225153636874.png)

#### 3.6.2 局域网交换机及其工作原理



以太网交换机特点：

以太网交换机的每个端口都直接与主机相连，并且一般都工作在全双工方式。

交换机能同时连通许多对的端口，使每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据。 

以太网交换机由于使用了专用的交换结构芯片，结合直通交换方式（cut through）使其交换速率很高

以太网交换机可以独占传输媒体的带宽



![image-20221225153836208](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225153836208.png)

##### **交换机工作原理**

学习源地址

丢弃同网帧

转发异网帧

广播未知帧

广播广播帧

![image-20221225153732952](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225153732952.png)

##### VLAN技术

![image-20221225153941549](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225153941549.png)

![image-20221225154004046](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计网\image-20221225154004046.png)

## Chapter 4 网络层

### 4.1 网路层的功能

#### 4.1.1 路由与转发

#### 4.1.2 拥塞控制

### 4.2 路由算法

#### 4.2.1 距离向量路由算法

#### 4.2.2 链路状态路由算法

#### 4.2.3 层次路由

### 4.3 IPv4

#### 4.3.1 IPv4分组



IPV4首部长度以4字节为一个单位 

占4位 

最长1111表示60字节

因此IPV4首部最长60字节。



IPv4总长度以字节为单位,

占16位，

最长可表示2<sup>16</sup>-1

因此IPv4最长65535字节

注意 总长度不得超过MTU



IPV4片偏移以**<font color = 'red'>8字节</font>**为一个单位

占13位



#### 4.3.2 IPv4地址与NAT

#### 4.3.3 子网划分与子网掩码、CIDR

#### 4.3.4 ARP协议、DHCP协议与ICMP协议

### 4.4 IPv6

不考

### 4.5 路由协议

#### 4.5.1 自治系统

#### 4.5.2 域内路由和域间路由

#### 4.5.3 RIP路由协议

不考

#### 4.5.4 OSPF路由协议

#### 4.5.5 BGP路由协议

### 4.6 IP组播

不考

### 4.7 移动IP

不考

### 4.8 网络层设备

#### 4.8.1 路由器的组成与功能

#### 4.8.2 路由表与路由转发



## Chapter 5 传输层

### 5.1 传输层提供的服务

#### 5.1.1 传输层的功能

#### 5.1.2 传输层寻址与端口

#### 5.1.3 无连接服务与面向连接服务

### 5.2 UDP协议

#### 5.2.1 UDP数据报

#### 5.2.2 UDP校验

### 5.3 TCP协议

#### 5.3.1 TCP段

#### 5.3.2 TCP连接管理

#### 5.3.3 TCP可靠传输

#### 5.3.4 TCP流量控制与拥塞控制

## Chapter  6 应用层

### 6.1 网络应用模型

#### 6.1.1 CS模型

#### 6.1.2 P2P模型

不考

### 6.2 域名系统(DNS)

DNS使用UDP报文

#### 6.2.1 层次域名空间

#### 6.2.2 域名服务器

#### 6.2.3 域名解析过程

迭代查询、递归查询



### 6.3 文件传输协议(FTP)

不考

### 6.4 电子邮件

#### 6.4.1 电子邮件系统的组成结构

#### 6.4.2 电子邮件格式与MIME

#### 6.4.3 SMTP协议与POP3协议

### 6.5 万维网(www)

#### 6.5.1 WWW的概念与组成结构

#### 6.5.2 HTTP协议



## Chapter  7 各层设备

### 路由器



路由器并不会转发广播数据，也就是说广播数据到达路由器，是会被丢弃的

## Chapter  8 各层协议汇总

### 8.1 数据链路层协议

#### 



### 8.2 网络层协议

### 8.3 传输层协议

### 8.4 应用层协议

## Chapter  9 各层应用汇总

### 9.1 PING

PING是分组网间探测，主要用于测试两台主机之间的连接性能。

PING使用了ICMP回送请求和回答报文。

**PING工作在应用层，它直接使用网络层的ICMP，而不使用传输层的UDP/TCP。**

因此我们只能ping一个ip地址/DNS域名，不能ping套接字，因为没有端口号。

**Attention**：

有的vpn工作在应用层，即使你通过vpn能访问外网，也无法ping外网。

### 9.2 



## Chapter 10 零碎知识点



### 10.1 网段、冲突域、广播域与自治系统



**网段**

是物理层的定义，使用同一物理层设备（传输介质，中继器，集线器等）能够直接通讯的那一部分 
1. 使用同一物理层的设备之间必然通过相同的传输介质直接相互连接，（如交叉双绞线直接连接的两台主机），是一个网段 
2. 两组其传输介质并非直接相连的网络设备，如果它们的传输介质通过工作在物理层的扩展设备如中继器和集线器等转接连接，则仍然被视为同一物理层中的设备，是一个网段 
3. 工作在数据链路层或更高层的设备如网桥、交换机、路由器等等，由它们连接起来的两组设备仍然分别处于各自独立的物理层，是两个网段

总的来说，**如果没有第二层及以上的设备的隔离，那么这些设备都在一个网段之中。**



**冲突域**

一次载波监听的范围，一个站点向另一个站点发出信号。除目的站点外，有多少站点能收到这个信号，这些站点就构成一个冲突域。

一般可以被第二层及以上的设备隔离。



**广播域**

一次广播发生的范围，多个冲突域构成一个广播域。

因为路由器不会转发广播信号，一般可以被路由器等第三层及以上的设备隔离。

**利用虚拟局域网技术VLAN可以让交换机隔离广播域！！！**



**广播域与冲突域的区别**

1. **广播域可以跨网段，而冲突域只是发生的同一个网段的。**以太网中，冲突域是由hub组织的。一个hub就是一个冲突域。交换机的每个端口都是一个冲突域。网段，又叫潜在冲突域。

2. 冲突域在同一个冲突域中的每一个节点都能收到所有被发送的帧。广播域在网络中能接收任一设备发出的广播帧的所有设备的集合 。

3. 冲突域是基于第一层（物理层），而广播域是机于第二层（数据链路层） 。

4. 广播域就是说，如果站点发出一个广播信号后能接收到这个信号的范围，**通常来说一个局域网就是一个广播域。**（用路由器连接的除外）。冲突域是一个站点向另一个站点发出信号，除目的站点外，有多少站点能收到这个信号，这些站点就构成一个冲突域。

5. HUB 所有端口都在同一个广播域，冲突域内。Swith所有端口都在同一个广播域内，而每一个端口就是一个冲突域。



**自治系统**

自治系统（AS）是由一个技术管理机构管理，使用统一选路策略的一组路由器集合。

自治系统编号范围：1-65535，其中1-64511是互联网上注册公有AS号，类似公网IP地址。

64512-65535是私有AS号，类似私网IP地址。

自治系统是使用同一个内部网关协议(路由选择协议)的系统，一般由很多个局域网广播域组成。一个自治系统内的所有路由器都必须是连通的。



### 10.2 广播帧、未知帧、同网帧、异网帧



**未知帧:**
第一,Switch的转发表中没有该帧的目的Mac地址
第二,DEST ADDR(目的地址)不是全F(十六进制数)

**广播帧：**

我们把目标地址为全F的帧叫做广播帧，对应成二进制数字就是全为1

**同网帧与异网帧：**

同网异网说的是一个包的来源端口和去往端口是不是一样的(端口指交换机端口)





**ARP包就是一个广播帧**

网络通电之后我们要发包首先发送的就是ARP包,它的作用就是学习地址.

比方说我们从主机pc3->主机pc4发一个ICMP包,从图中我们可以看出ARP包会先于我们自定的ICMP包之前发,从上边图我们可以知道，ARP是一个广播帧。

**发包的详细过程**

1.ARP包先发送

2.ARP包到达集线器(Hub)

**Hub的特性：简要概述：就是不管是什么帧，只要你来就统统广播**


3.该帧到达交换机(Switch),那么Switch将会学习该帧的源地址并且转发该帧。

因为该帧是一个广播帧所以交换机(Switch)会将帧广播出去。

**Switch的特性:丢弃同网帧、转发异网帧、广播广播帧、广播未知帧**


查看转发表：


整体展示：


问:仔细看上图,你发现了什么呢？

答:你会发现左边部分主机上的包上边有(X)叉号,这又是为什么呢?是包出错了？

其实不然,

这是ARP协议的工作工程: 当发现IP地址不是自己所要找的目标地址,那么就会将该包丢弃(换句话说就是不是自己想要的,那么我就直接扔了,不管了)。对于匹配成功的，则会返回ARP包并把自己的Mac地址写到返回的包中。

如下图：


4.Hub广播从pc4发送的包。

当包到达交换机时,交换机学习源地址并且转发该帧,因为他们可以认为是连接在同一个端口上(交换机上的),根据Switch的特性,那么将丢弃同网帧：
查看转发表(确实是同一个端口上的)：


同时,该包也传送到了发送ARP包的pc3主机上,至此,主机pc3就知道了主机pc4的Mac地址,也就是知道了他在那里,现在就可以正常发包啦！
整体展示：


5.发送ICMP包


6.Hub广播该帧（前边已经介绍过Hub，这里不再做赘述）
直接上图：


7.收到后发送响应：
直接上图：


8.完成


上边发包内容的小结
总结：上边讲解了哪些呢？
对于交换机我们演示了：学习源地址、丢弃同网帧、广播广播帧（ARP使我们举的例子）
对于Hub:我们了解了Hub的工作过程,不管是谁,都需要广播,(管他是神还是魔，都要一视同仁，平等对待，哈哈哈这里说这句话就是想帮助大家能更好的理解)
接下来,我们来学习转发异网帧和广播未知帧
注：这两种都是对Switch来讲的，Hub到此就讲完啦！
接着讲解,坚持就是胜利,加油!!!
一.转发异网帧

1.我们从主机pc3->主机pc5发包,按照上边讲的一样,先要发送ARP包,知道目的主机的Mac地址是多少。


2.主机pc5返回一个ARP包,其中包含着自己的Mac地址,当该包到达交换机的时候(敲黑板),Switch学习源地址,并把该包转发出去(重点:转发的话先查表,一查,发现来源端口和去往端口是不一样的,那么这个就叫做转发异网帧)

如下图所示：

该包到达交换机(学习源地址):

整体展示：


3.至此,知道了目的主机的Mac地址,可以发包啦,上边已有发包过程,就不写啦(偷个懒)！！！


二、广播未知帧
未知帧(再啰嗦一遍)：

Switch的转发表中没有该帧的目的Mac地址
并且目标地址（DEST ADDR）不是全F（对应二进制就是全1）
1.还是举主机pc3->主机pc4发包

上边我们已经知道,主机pc3->pc4主机可以正常发包了

而且转发表中也已经记录了主机pc3和主机pc4

如下图：


现在我们清空转发表，有两种情况

第一种是直接重启转发表.但是不建议使用这个.所以具体的我就不讲啦！若你想学怎样操作的话.可以下方留言

第二种是命令行操作

如下，若有问题，欢迎下方留言。


转发表状态：现在什么都没有


1.现在我们让主机pc3->主机pc4发包，我们发一个ICMP的包


2.到达Switch和主机pc4


3.主机pc4返回一个响应,Switch会将该帧广播出去,该帧是一个未知帧,转发表中没有,并且目的地址不是全F（十六进制,符合未知帧的条件)
该帧信息如下：


整体展示：

4.丢弃不需要的包，返回需要的包

### 10.3 单播、广播、组播


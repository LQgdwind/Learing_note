# 计算机组成原理与体系结构笔记

## Chapter 1 概论

## Chapter 2 数据的机器层次表示

### 2.1 数值数据的表示
### 2.2 机器数的定点表示与浮点表示

#### 2.2.1 定点表示法



在定点表示法中约定：所有数据的小数点位置固定不变。

通常，把小数点固定在有效数位的最前面或末尾，这就形成了两类定点数。



Attention：

**补码与原码表示法表示范围不一样**，因为原码中零有两种表示方法，故只能映射2<sup>n</sup>-1个数，而补码可以映射2<sup>n</sup>个数。



**定点小数**

![image-20221101203406046](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101203406046.png)

极值与表示范围：

![image-20221101203431348](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101203431348.png)

![image-20221101203506679](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101203506679.png)

![image-20221101203520146](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101203520146.png)

![image-20221101203636375](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101203636375.png)



**定点整数**

![image-20221101203820576](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101203820576.png)

![image-20221101203834340](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101203834340.png)

![image-20221101203851025](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101203851025.png)



#### 2.2.2 浮点表示法

![image-20221101203953857](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101203953857.png)

![image-20221101204105480](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101204105480.png)



**浮点数的表示范围**

![image-20221101204129608](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101204129608.png)

![image-20221101204148860](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101204148860.png)

![image-20221101204215722](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101204215722.png)



**规格化浮点数**

![image-20221101204319712](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101204319712.png)

![image-20221101204333630](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101204333630.png)

![image-20221101204412808](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101204412808.png)

总的来说，浮点表示法的范围汇总如下：

![image-20221101204456681](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101204456681.png)

#### 2.2.3 浮点数阶码的移码表示法

![image-20221101215750555](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101215750555.png)



**移码偏置值**

注意：

在IEEE754标准中偏置值选择了2<sup>n</sup>-1。



![image-20221101215817280](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101215817280.png)

![image-20221101220012454](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101220012454.png)



一般用2<sup>n</sup>-1更多

![image-20221101221041548](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101221041548.png)

![image-20221101221117483](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101221117483.png)

![image-20221101221236610](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101221236610.png)

#### 2.2.5  IEEE754标准浮点数

![image-20221101222413264](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101222413264.png)

![image-20221101222447029](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101222447029.png)



例题：

![image-20221101223051707](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101223051707.png)

![image-20221101223104683](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221101223104683.png)



**Attention:**

IEEE 754标准特殊情况:

阶码全0，尾数亦全0 : 表示0

阶码全1，尾数全0：表示无穷

阶码全1，尾数不为0：表示NaN

阶码全0，尾数不为0：表示2<sup>-126</sup>×0.M 也就是把尾数小数点前默认的1变成0



### 2.3 非数值数据的表示
### 2.4 十进制数和数串的表示
### 2.5 不同类型的数据表示举例
### 2.6 数据校验码

## Chapter 3 指令系统

### 3.1 指令格式

#### 3.1.1 机器指令的基本格式

由地址码和操作码构成

操作码：指明操作的性质及功能。

地址码：指明操作数的地址，特殊情况下也可能直接给出操作数本身。



指令长度：

指令的长度是指一条指令中所包含的二进制代码的位数，它取决于操作码字段的长度、操作数地址的个数及长度。

指令长度应：             

① 尽可能短            

② 等于字节的整数倍            

指令长度可以等于机器字长，也可以大于或小于机器字长。

在一个指令系统中，若所有指令的长度都是相等的，称为定长指令字结构；若各种指令的长度随指令功能而异，称为变长指令字结构。

#### 3.1.2 地址码结构

以双操作数指令作为例子

有五种：

四地址指令、三地址指令、二地址指令、一地址指令、零地址指令

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216150014003.png" alt="image-20221216150014003" style="zoom:50%;" />

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216150029076.png" alt="image-20221216150029076" style="zoom:50%;" />

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216150042630.png" alt="image-20221216150042630" style="zoom:50%;" />

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216150054735.png" alt="image-20221216150054735" style="zoom:50%;" />

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216150109755.png" alt="image-20221216150109755" style="zoom:50%;" />

指令中地址个数的选取要考虑诸多的因素。从缩短程序长度，用户使用方便，增加操作并行度等方面来看，选用三地址指令格式较好；从缩短指令长度，减少访存次数，简化硬件设计等方面来看，一地址指令格式较好。对于同一个问题，用三地址指令编写的程序最短，但指令长度最长，而用二、一、零地址指令来编写程序，程序的长度一个比一个长，但指令的长度一个比一个短。

#### 3.1.3 指令的操作码

**指令系统中的每一条指令都有一个唯一确定的操作码**，指令不同，其操作码的编码也不同。为了能表示整个指令系统中的全部指令，指令的操作码字段应当具有足够的位数。



<font color = "red">指令的操作码编码</font>

指令操作码的编码可以分为规整型和非规整型两类

规整型（定长编码）

非规整型（变长编码）



规整型

操作码字段的位数和位置是固定的。           

假定：指令系统共有m条指令，指令中操作码字段的位数为N位，

则有如下关系式：            

N ≥ log<sub>2</sub> m



**非规整型**

最常用的非规整型编码方式是扩展操作码法：            

让操作数地址个数多的指令（如三地址指令）的操作码字段短些，操作数地址个数少的指令（如一或零地址指令）的操作码字段长些。

**<font color = 'red'>拓展操作码设计</font>**

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216151742068.png" alt="image-20221216151742068" style="zoom:67%;" />

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216151754984.png" alt="image-20221216151754984" style="zoom:67%;" />

### 3.2 寻址技术

寻址，指的是寻找操作数的地址或下一条将要执行的指令地址。寻址技术包括编址方式和寻址方式。

#### 3.2.1 编址方式

通常，指令中的地址码字段将指出操作数的来源和去向，而操作数则存放在相应的存储设备中。在计算机中需要编址的设备主要有CPU中的通用寄存器、主存储器和输入输出设备等3种。

编制单位：

字编址/字节编址/位编址

**字编址**

编址单位=访问单位            

每个编址单位所包含的信息量（二进制位数）与读或写一次寄存器、主存所获得的信息量是相同的。早期的大多数机器都采用这种编址方式。

**字节编址**

字节编址是为了适应非数值计算的需要。字节编址方式使编址单位与信息的基本单位（一个字节）相一致，这是它的最大优点。然而，如果主存的访问单位也是一个字节的话，那么主存的频带就太窄了。            

编址单位＜访问单位            

通常主存的访问单位是编址单位的若干倍。

**位编址**

部分计算机系统采用位编址方式。



**指令中地址码的位数**

**指令格式中每个地址码的位数是与主存容量和最小寻址单位（即编址单位）有关联的。**

主存容量越大，所需的地址码位数就越长。对于相同容量来说，如果以字节为最小寻址单位，地址码的位数就需要长些；如果以字为最小寻址单位（假定字长为16位或更长），地址码的位数可以减少。

设某机主存容量为2<sup>20</sup> 个字节，机器字长32位。若最小寻址单位为字节（按字节编址），其地址码应为20位；若最小寻址单位为字（按字编址），其地址码只需18位。

#### 3.2.2 数据寻址和指令寻址

寻址可以分为数据寻址和指令寻址。

寻找操作数的地址称为数据寻址，数据寻址方式较多，其最终目的都是寻找所需要的操作数。

寻找下一条将要执行的指令地址称为指令寻址，指令寻址比较简单，它又可以细分为顺序寻址和跳跃寻址。

顺序寻址可通过程序计数器PC加1，自动形成下一条指令的地址；

跳跃寻址则需要通过程序转移类指令实现。            

跳跃寻址的转移地址形成方式有三种：直接（绝对）、相对和间接寻址，它与下面介绍的数据寻址方式中的直接、相对和间接寻址是相同的，只不过寻找到的不是操作数的有效地址而是转移的有效地址而已。



#### 3.2.2 基本的数据寻址方式

寻址方式是根据指令中给出的地址码字段寻找真实操作数地址的方式。 

![image-20221216153731816](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216153731816.png)

九大方式:

立即数、寄存器、直接、间接、寄存器间接、变址、基址、相对、页面寻址

**1.立即寻址**

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216153828477.png" alt="image-20221216153828477" style="zoom:67%;" />

**2.寄存器寻址**

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216153926462.png" alt="image-20221216153926462" style="zoom:67%;" />

**3.直接寻址**

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216154016471.png" alt="image-20221216154016471" style="zoom:67%;" />

**4.间接寻址**
<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216154143747.png" alt="image-20221216154143747" style="zoom:67%;" />

间接寻址要比直接寻址灵活得多，它的主要优点为：            

1.扩大了寻址范围，可用指令的短地址访问大的主存空间。           

2.可将主存单元作为程序的地址指针，用以指示操作数在主存中的位置。当操作数的地址需要改变时，不必修改指令，只需修改存放有效地址的那个主存单元（间接地址单元）的内容就可以了。

![image-20221216154310510](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216154310510.png)

**5.寄存器间接寻址**

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216190704523.png" alt="image-20221216190704523" style="zoom:67%;" />

**6.变址寻址**
<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216190747070.png" alt="image-20221216190747070" style="zoom:67%;" />

变址寻址是一种广泛采用的寻址方式，通常指令中的形式地址作为基准地址，而RX的内容作为修改量。在遇到需要频繁修改地址时，无须修改指令，只要修改变址值就可以了。            

例如：要把一组连续存放在主存单元中的数据（首地址是A）依次传送到另一存储区（首地址为B）中去，则只需在指令中指明两个存储区的首地址A和B（形式地址），用同一变址寄存器提供修改量K，即可实现(A+K)→B+K。变址寄存器的内容在每次传送之后自动地修改。 

**7.基址寻址**

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216191207752.png" alt="image-20221216191207752" style="zoom:67%;" />

基址寻址和变址寻址在形成有效地址时所用的算法是相同的，而且在一些计算机中，这两种寻址方式都是由同样的硬件来实现的。            

但这两种寻址方式应用的场合不同，变址寻址是面向用户的，用于访问字符串、向量和数组等成批数据；而基址寻址面向系统，主要用于逻辑地址和物理地址的变换，用以解决程序在主存中的再定位和扩大寻址空间等问题。在某些大型机中，基址寄存器只能由特权指令来管理，用户指令无权操作和修改。

**8.相对寻址**

![image-20221216191308259](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216191308259.png)

相对寻址方式的特点：    

1.操作数的地址不是固定的，它随着PC值的变化而变化，并且与指令地址之间总是相差一个固定值D。当指令地址改变时，由于其位移量不变，使得操作数与指令在可用的存储区内一起移动，所以仍能保证程序的正确执行。采用PC相对寻址方式编写的程序可在主存中任意浮动，它放在主存的任何地方，所执行的效果都是一样的。   

2.由于指令中给出的位移量可正、可负，所以对于指令地址而言，操作数地址可能在指令地址之前或之后。

**9.页面寻址**

页面寻址相当于将整个主存空间分成若干个大小相同的区，每个区称为一页，每页有若干个主存单元。每页都有自己的编号，称为页面地址；页面内的每个主存单元也有自己的编号，称为页内地址。这样，操作数的有效地址就被分为两部分：前部为页面地址，后部为页内地址。

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216191657090.png" alt="image-20221216191657090" style="zoom:67%;" />

这三种方式分别为基页寻址、当前页寻址、页寄存器寻址

*基页寻址*

由于页面地址等于全0，所以有效地址 <font color = 'red'>EA=0∥A</font>（∥在这里表示简单拼接），操作数S在零页面中。

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216191910883.png" alt="image-20221216191910883" style="zoom:67%;" />



*当前页寻址*

页面地址就等于程序计数器PC的高位部分，所以有效地址 <font color = 'red'>EA=(PC)<sub>H</sub>∥A</font>，操作数S与指令本身处于同一页面中。

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216192336425.png" alt="image-20221216192336425" style="zoom:67%;" />



*页寄存器寻址*

页面地址取自页寄存器，与形式地址相拼接形成操作数有效地址：            

<font color = 'red'>EA=(页寄存器)∥A</font>



有些计算机在指令格式中设置了一个页面标志位（Z/C）。当Z/C=0，表示零页寻址，当Z/C=1，表示当前页寻址。



**各种寻址方式的速度比较**

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216192548202.png" alt="image-20221216192548202" style="zoom:67%;" />



**寻址技术的标识**

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216192615206.png" alt="image-20221216192615206" style="zoom:67%;" />

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216192638097.png" alt="image-20221216192638097" style="zoom:67%;" />

### 3.3 堆栈与堆栈操作

### 3.4 指令类型
### 3.5 指令系统的发展

## Chapter 4 数值的机器运算

运算器是计算机进行算术运算和逻辑运算的主要部件，运算器的逻辑结构取决于机器的指令系统、数据表示方法和运算方法等。

本章主要讨论数值数据在计算机中实现算术运算和逻辑运算的方法，以及运算部件的基本结构和工作原理。

### 4.1 基本算术运算的实现

### 4.2 定点加减运算

#### 4.2.2 **<font color = 'red'>补码加减运算</font>**

补码加法：

两个补码表示的数相加，符号位参加运算，且两数和的补码等于两数补码之和

![image-20221215103127853](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221215103127853.png)

补码减法：

根据补码加法公式可推出：

![image-20221215103159530](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221215103159530.png)

已知[Y]补求[-Y]补的方法是：将[Y]补连同符号位一起求反，末尾加“1”。

[-Y]补被称为[Y]补的机器负数，由[Y]补求[-Y]补的过程称为对[Y]补变补（求补），表示为：

![image-20221215103351194](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221215103351194.png)



**补码表示与变补的区别**

![image-20221215103603862](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221215103603862.png)



**<font color = 'red'>补码加减运算法则</font>**

补码加减运算规则如下：

⑴ 参加运算的两个操作数均用补码表示；

⑵ 符号位作为数的一部分参加运算；

⑶ 若做加法，则两数直接相加；若做减法，则将被减数与减数的机器负数相加；

⑷ 运算结果用补码表示。

![image-20221215103719694](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221215103719694.png)



#### 4.2.3 <font color = 'red'>补码的溢出判断与检测方法</font>

溢出的产生

在补码加减运算中，有时会遇到这样的情况：两个正数相加，而结果的符号位却为1（结果为负）；两个负数相加，而结果的符号位却为0（结果为正）。



设参加运算的两数为X、Y，做加法运算。

若X、Y异号，不会溢出。

若X、Y同号，运算结果为正且大于所能表示的最大正数或运算结果为负且小于所能表示的最小负数（绝对值最大的负数）时，产生溢出。将两正数相加产生的溢出称为正溢；反之，两负数相加产生的溢出称为负溢。



**<font color = 'red'>溢出检测方法</font>**

![image-20221215110116622](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221215110116622.png)

**1.采用一个符号位**

两正数相加，结果为负表明产生正溢；

两负数相加，结果为正表明产生负溢。

因此可得出采用一个符号位检测溢出的方法：

![image-20221215110041377](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221215110041377.png)

**2. 采用进位位**

![image-20221215183251865](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221215183251865.png)

两正数相加，当最高有效位产生进位(C1=1)而符号位不产生进位(Cs=0)时，发生正溢

两负数相加，当最高有效位没有进位(C1=0)而符号位产生进位(Cs=1)时，发生负溢

![image-20221215183303375](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221215183303375.png)

**3.采用变形补码(双符号位补码)**

在双符号位的情况下，把左边的符号位S<sub>s1</sub>叫做真符，因为它代表了改数真正的符号，两个符号位都作为数的一部分参加运算。这种编码称为变形补码。

![image-20221215183448772](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221215183448772.png)

当两个符号位的值不一致的时候，表明产生溢出

![image-20221215184830254](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221215184830254.png)

### 4.3 带符号数的移位和舍入操作

**补码移位原则**

负数的补码左移后的空出位补0.右移后的空出位补1

![image-20221215201537781](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221215201537781.png)

### 4.4 定点乘法运算

**一位原码定点乘法**

用两个操作数的绝对值相乘，乘积的符号为两操作数符号的异或值（同号为正，异号为负）。

![image-20221216100019742](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216100019742.png)

原码一位乘法的规则为：

① 参加运算的操作数取其绝对值；

② 令乘数的最低位为判断位，若为“1”，加被乘数，若为“0”，不加被乘数（加0）；

③ 累加后的部分积右移一位；

④ 重复n次②和③；

⑤ 符号位单独处理，同号为正，异号为负。



乘法运算需要3个寄存器：

A寄存器：部分积与最后乘积的高位部分，初值为0。

B寄存器：被乘数X。

C寄存器：乘数Y，运算后C寄存器中不再需要保留乘数，改为存放乘积的低位部分。



例子：
![image-20221216100347577](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216100347577.png)



**<font color = 'red'>补码一位乘法</font>**

**Booth乘法**

![image-20221216100555010](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216100555010.png)

Booth乘法规则如下：

① 参加运算的数用补码表示；

② 符号位参加运算；

③ 乘数最低位后面增加一位附加位Yn+1，其初值为0；

④ 由于每求一次部分积要右移一位，所以乘数的最低两位Yn、Yn+1的值决定了每次应执行的操作；

⑤ 移位按补码右移规则进行；

⑥ 共需做n+1次累加，n次移位，第n+1次不移位。

![image-20221216100636298](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216100636298.png)

例子：

![image-20221216100748539](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216100748539.png)

### 4.5 定点除法运算

#### 4.5.1 原码除法运算

**原码不恢复余数法**

![image-20221216104227088](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216104227088.png)

原码加减交替除法规则：
1) 第一步做被除数减去除数。
2) 当余数为正时，商“1”，余数左移一位，减除数；当余数为负时，商“0”，余数左移一
    位，加除数。
3) 重复步骤2)，共做n+1/ n+2步加减运算(n步移位)。



除法运算需要3个寄存器：

A寄存器：存放被除数X，最后A寄存器中剩下的是扩大了若干倍的余数。运算过程中A寄存器的内容将不断地发生变化。

B寄存器：存放除数Y。

C寄存器：存放商Q，它的初值为0。



例子：

![image-20221216104825477](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216104825477.png)

![image-20221216141509143](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216141509143.png)



**Tips:**

需要指出的是，在定点小数除法运算时，为了防止溢出，要求被除数的绝对值小于除数的绝对值，即|X|＜|Y|，且除数不能为0。另外，在原码加减交替法中，当最终余数为负数时，必须恢复一次余数，使之变为真余数，注意此时不需要再左移了。



**<font color = 'red'>补码除法运算</font>**

被除数和除数都用补码表示，符号位参与运算

上商规则：
![image-20221216144200367](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221216144200367.png)



<font color = 'red'>补码加减交替除法规则</font>

1) 被除数与除数同号，被除数减去除数；被除数与除数异号，被除数加上除数。
2) 余数和除数同号，商上1，余数左移一位，下次减除数；余数和除数异号，商上0，余数左移一位，下次加除数。
3) 重复步骤2)，包括符号位在内，共做n+1步加减运算(n步移位)。
4) 商的末位恒置1。



例子：

![image-20221216144517865](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221216144517865.png)

### 4.6 规格化浮点运算

### 4.7 十进制整数的加减运算

### 4.8 逻辑运算与实现

### 4.9 运算器的基本组成与实例



## Chapter 5 存储系统和结构

![image-1](.\image\计组\1.png)

### 5.1 存储系统的组成

![](.\image\计组\2.png)

#### 5.1.1 存储器分类



**按照存储器在计算机系统中的作用分类**

1.高速缓冲存储器

2.主存储器

3.辅助存储器



**按照存取方式分类**

1.随机访问存储器（Random Access Memory,**RAM**)

CPU可以对存储器中的内容随机地存取。

2.只读存储器(Read Only Memory,**ROM**)

存储器内容只能随机读出而不能读入

3.顺序存取存储器(**SAM**)

SAM的内容只能按某种顺序存取，存取时间与信息在存储体上的物理位置有关。

**磁带机**就属于这类存储器。

4.直接存取存储器(**DAM**)

当要存取所需的信息时，第一步直接指向整个存储器中的某个小区域（如磁盘上的磁道），第二步在小区域内顺序检索或等待，直至找到目的地后再进行读写操作。

**磁盘机**就属于这样一类存储器。

由于SAM和DAM的存取时间都与存储体的物理位置有关，所以又通常把它们统称为**串行访问存储器**。



**按照存储介质分类**

1.磁芯存储器

用两种不同的剩磁状态表示0和1，信息可以长期存储，但是是破坏性读出。

2.半导体存储器

主要有MOS和双极型(TTL、ECL)两种。半导体存储的信息会因为断电而丢失。

3.磁表面存储器

在金属或者塑料基体上，涂覆一层磁性材料，用磁层存储信息，常见的有磁盘、磁带等，用作辅助存储器

4.光存储器

采用激光技术控制访问的存储器，一般分为只读式，一次写入式，可改写式



**按信息的可保存性分类**

1.易失性存储器

断电后存储信息消失，如半导体RAM

2.非易失性存储器

断电后信息依旧被保存，如ROM、磁芯存储器、磁表面存储器和光存储器



根据读出时信息是否被破坏可以将读出操作分为破坏性读出和非破坏性读出。破坏性读出信息后需要进行一个重写(再生)操作。



#### 5.1.2 存储系统层次结构

由高速缓冲存储器、主存储器、辅助存储器构成的三级存储系统可以分为两个层次



其中高速缓存和主存间称为**Cache-主存存储层次**（Cache存储系统）

Cache存储系统是为解决主存速度不足而提出来的。

由于**Cache存储系统全部用硬件来调度**，因此它对系统程序员和应用程序员都是透明的。



主存和辅助存储器间称为**主存-辅存存储层次**（虚拟存储系统）

虚拟存储系统是为解决主存容量不足而提出来的。

由于虚拟存储系统需要通过操作系统来调度，因此对系统程序员是不透明的，但对应用程序员是透明的。

### 5.2 主存储器的组织

主存储器是整个存储系统的核心，它用来存放计算机运行期间所需要的程序和数据，CPU可直接随机地对它进行访问。

#### 5.2.1 <font color = 'blue'>主存储器的基本结构</font>

![image-20221026190107243](.\image\计组\3.png)



存储体是主存储器的核心，程序和数据都存放在存储体中。



地址译码驱动电路实际上包含译码器和驱动器两部分。

译码器将地址总线输入的地址码转换成与之对应的译码输出线上的有效电平，以表示选中了某一单元，并由驱动器提供驱动电流去驱动相应的读、写电路，完成对被选中单元的读、写操作。



I/O和读写电路包括读出放大器、写入电路和读/写控制电路，用以完成被选中存储单元中各位的读出和写入操作。

存储器的读/写操作是在控制器的控制下进行的。半导体存储器芯片中的控制电路，必须接收到来自控制器的读/写命令或写入允许信号后，才能实现正确的读/写操作。


####  5.2.2 主存储器的存储单元



**位**是二进制数的最基本单位，也是**存储器存储信息的最小单位**。



一个二进制数由若干位组成，当这个二进制数作为一个整体存入或取出时，这个数称为存储字。



存放存储字或存储字节的主存空间称为存储单元或主存单元。

大量存储单元的集合构成一个存储体(MB)，程序和数据都存放在存储体中，它是存储器的核心。



一个存储单元有可能放一个字节，也有可能放一个字，这是由计算机的结构决定的。

对于字节编址的计算机，最小寻址单位是一个字节，

对于字编址的计算机，最小寻址单位是一个字。



**存储单元是CPU对主存可访问操作的最小存储单位。**



小端方案与大端方案

![image-20221026193432410](.\image\计组\4.png)

![image-20221026193503410](.\image\计组\5.png)

####  5.2.3 <font color = 'blue'>主存储器的主要技术指标</font>

**存储容量**

![image-20221026193610189](.\image\计组\6.png)

注意:

1. 对于字节编址的计算机，常常使用KB/MB/GB作为存储容量的单位

2. 对于字编址的计算机，通常用**字容量×字长**作为存储容量的单位



**存储速度**

![image-20221026193818954](.\image\计组\7.png)

![image-20221026193929882](.\image\计组\8.png)

一般情况下用不到存储时间，用的都是存储周期，也就是相邻两次访问存储器操作之间所需要的最短时间。



**主存带宽**

![image-20221026194306869](.\image\计组\9.png)

为了提高主存带宽，我们可以考虑：1.缩短存取周期 2.增加存储字长 3.增加存储体。

注：**公式要记住**



####  5.2.4 数据在主存中的存放

一般来说，**数据在主存中有三种存放方法**:

不浪费存储器资源的存放方法、从存储字的起始位置开始存放方法、边界对齐的数据存放方法

符合张继老师所说的“三板斧”：两个极端，一个中庸。

一般来说，**读/写的数据有四种不同长度:**

字节（8位）、半字（16位）、单字（32位）和双字（64位）。



**不浪费存储器资源的存放方法**

![image-20221026200417116](.\image\计组\10.png)



**从存储字的起始位置开始存放方法**

![image-20221026200450874](.\image\计组\11.png)



**边界对齐的数据存放方法**

![image-20221026200656115](.\image\计组\12.png)



### 5.3 半导体随机存储器和只读存储器

主存储器通常分为**RAM**和**ROM**两大部分。

RAM(random access memory)可读可写，

ROM(read-only memory)只能读不能写。

下面重点讨论RAM的工作原理与结构，以及ROM的基本类型。

####  5.3.1 RAM记忆单元电路

![image-20221026205641553](.\image\计组\13.png)

常见的有6管SRAM、4管DRAM、1管DRAM

####  5.3.2 动态RAM的刷新

DRAM的存储电路以电容为基础，为了维持MOS型动态记忆单元的存储信息，每隔一定时间必须对存储体中的所有记忆单元的栅极电容补充电荷，这个过程就是刷新。

刷新通常是按**行**进行的。

![image-20221026212030983](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\14.png)

**常见的刷新方式有三种：集中刷新、分散刷新、异步刷新**

同样符合“三板斧原则”



**集中刷新**

![image-20221026212222680](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\15.png)

![image-20221026212243618](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\16.png)



**分散刷新**

![image-20221026212409448](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\17.png)

![image-20221026212437407](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\18.png)



**异步刷新**

![image-20221026212536942](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\19.png)

![image-20221026212608577](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\20.png)



**MOS型动态RAM的刷新要注意几个问题：**

1. 刷新对CPU是透明的。
2. 刷新通常是一行一行地进行的，每一行中各记忆单元同时被刷新，故**刷新操作时仅需要行地址**，不需要列地址。
3. 刷新操作类似于读出操作。
4. 因为所有芯片同时被刷新，所以在考虑刷新问题时，应当从单个芯片的存储容量着手，而不是从整个存储器的容量着手。
5. 值得一提的是，刷新和重写（再生）是两个完全不同的概念，切不可加以混淆。重写是随机的，某个存储单元只有在破坏性读出之后才需要重写。而刷新是定时的，即使许多记忆单元长期未被访问，若不及时补充电荷的话，信息也会丢失。重写一般是按存储单元进行的，而刷新通常以存储体矩阵中的一行为单位进行的。

####  5.3.3 RAM芯片分析



##### **RAM芯片**

![image-20221026213418294](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\21.png)

存储芯片通过**地址线、数据线和控制线**与外部连接。



**地址线**是单向输入的，其数目与芯片容量有关。



**数据线**是双向的，既可输入，也可输出，其数目与数据位数有关。



**控制线**主要有读/写控制线（或写允许线）和片选线两种，

**读/写控制线**是用来决定芯片是进行读操作还是写操作的，**(ROM不能连)**

**片选线**是用来决定 该芯片是否被选中的。



**DRAM芯片把地址线分成相等的两部分，分两次从相同的引脚送入。**

两次输入的地址分别称为行地址和列地址，行地址由**行地址选通信号RAS**送入存储芯片，列地址由**列地址选通信号CAS**送入存储芯片。

由于采用了地址复用技术，**因此，DRAM芯片每增加一条地址线，实际上是增加了两位地址，也即增加了4倍的容量。**





##### 地址译码方式

地址译码电路能把地址线送来的地址信号翻译成对应存储单元的选择信号。

常见的有单译码和双译码两种。

**单译码**

![image-20221026214359110](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\22.png)

字结构的优点是结构简单，

缺点是使用的外围电路多，成本昂贵。更严重的是，当字数大大超过位数时，存储器会形成纵向很长而横向很窄的不合理结构。

所以这种方式只适用于容量不大的存储器。

**双译码**

![image-20221026214510200](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\23.png)

![image-20221026214618211](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\24.png)

![image-20221026215036647](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\25.png)

##### RAM的读/写时序

**(1)SRAM读/写时序**

读周期表示对该芯片进行两次连续读操作的最小间隔时间。

在此期间，地址输入信息不允许改变，片选信号CS在地址有效之后变为有效，使芯片被选中，最后在数据线上得到读出的信号。

写允许信号WE在读周期中保持高电平。

**WE=1、CS=0**

![image-20221026225545757](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\26.png)

写周期与读周期相似，但除了要加地址和片选信号外，还要加一个低电平有效的写入脉冲WE，并提供写入数据。

**WE=0、CS=0**

![image-20221026225901081](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\27.png)

**(2)DRAM读/写时序**

![image-20221026230344356](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\28.png)

####  5.3.4 半导体只读存储器

ROM的最大优点是具有非易失性，即使电源断电，ROM中存储的信息也不会丢失。

ROM的类型有:

1.掩膜式ROM（MROM）2.一次可编程ROM（PROM）3.可擦除可编程ROM（EPROM）4.闪速存储器（flash memory）

### 5.4 主存储器的连接与控制

####  5.4.1 <font color = 'red'>主存容量的扩展</font>

要组成一个主存，首先要考虑选片的问题，然后就是如何把芯片连接起来的问题。根据存储器所要求的容量和选定的存储芯片的容量，就可以计算出总的芯片数，即

 总片数＝ 总容量/芯片容量

**位扩展**

位扩展指只在位数方向扩展（加大字长），而芯片的字数和存储器的字数是一致的。位扩展的连接方式是将各存储芯片的地址线、片选线和读/写线相应地并联起来，而将各芯片的数据线单独列出。

![image-20221214195406993](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214195406993.png)

**字扩展**

字扩展是指仅在字数方向扩展，而位数不变。字扩展将芯片的地址线、数据线、读/写线并联，由片选信号来区分各个芯片。

![image-20221214195438108](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214195438108.png)

![image-20221214195528675](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214195528675.png)

**字和位同时扩展**

![image-20221214195607963](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214195607963.png)



####  5.4.2 <font color = 'blue'>存储芯片的地址分配和片选</font>

CPU要实现对存储单元的访问，首先要选择存储芯片，即进行片选；然后再从选中的芯片中依地址码选择出相应的存储单元，以进行数据的存取，这称为字选。片内的字选是由CPU送出的N条低位地址线完成的，地址线直接接到所有存储芯片的地址输入端（N由片内存储容量2<sup>N</sup> 决定），而片选信号则是通过高位地址得到的。实现片选的方法可分为3种：即线选法、全译码法和部分译码法。



片选主要有三种方法:

线选法

全译码法

**<font color = 'red'>部分译码法</font>**



**线选法**

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214212616043.png" alt="image-20221214212616043" style="zoom:67%;" />

![image-20221214212648014](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214212648014.png)

**全译码法**

![image-20221214213045662](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214213045662.png)

![image-20221214213102619](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214213102619.png)

**部分译码法**

![image-20221214213932026](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214213932026.png)

![image-20221214213945947](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214213945947.png)



**例题**

![image-20221214214013707](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214214013707.png)

![image-20221214214024572](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214214024572.png)

![image-20221214214034732](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214214034732.png)

![image-20221214214045075](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214214045075.png)

####  5.4.3 主存储器和CPU的连接

主存与CPU之间的硬链接

![image-20221214214701904](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214214701904.png)

**<font color = 'red'>CPU对主存的基本操作</font>**

![image-20221214214905746](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214214905746.png)

![image-20221214214916650](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214214916650.png)

![image-20221214214930523](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214214930523.png)

####  5.4.4 PC系列微型计算机的存储器接口

### 5.5 提高存储系统性能的技术

####  5.5.1 多体交叉存储技术

1.并行访问存储器

单体单字存储器

单体多字存储器(将地址线的高位作为数据线，减少最大访存)

2.交叉访问存储器

高位交叉访问存储器

地位交叉访问存储器

#### 5.5.2 <font color = 'red'>高速缓冲存储器</font>

**程序局部性原理**

程序的局部性包括：时间局部性和空间局部性。时间局部性是指如果一个存储单元被访问，则可能该单元会很快被再次访问。这是因为程序存在着循环。空间局部性是指如果一个存储单元被访问，则该单元邻近的单元也可能很快被访问。这是因为程序中大部分指令是顺序存储、顺序执行的，数据一般也是以向量、数组、树、表等形式簇聚地存储在一起的。

高速缓冲技术就是利用程序的局部性原理，把程序中正在使用的部分存放在一个高速的容量较小的Cache中，使CPU的访存操作大多数针对Cache进行，从而使程序的执行速度大大提高。

**Cache的基本结构**

Cache和主存都被分成若干个大小相等的块，每块由若干字节组成。由于Cache的容量远小于主存的容量，它保存的信息只是主存中最活跃的若干块的副本。

**Cache的读/写操作**

读操作：命中则直接读，否则访存，将该块信息一次性调入cache，若cache满需要调用替换算法

写操作：命中则 写直达/写回法，不命中则直接写入主存。

**<font color = 'red'>与Cache相关的计算</font>**

Cache的命中率：

在一个程序执行期间，设N<sub>c</sub>表示Cache完成存取的总次数，N<sub>m</sub>表示主存完成存取的总次数，h定义为命中率。

则有：![image-20221214221343321](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214221343321.png)

![image-20221214221357749](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214221357749.png)

效率 e 与 Cache命中率 有关
设 Cache 命中率 为 h，访问 Cache 的时间为 t<sub>c</sub>，
访问 主存 的时间为 t<sub>m</sub>

![image-20221214221503598](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214221503598.png)



<font color = 'red'>例题</font>

![image-20221214221537599](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214221537599.png)

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214221551550.png" alt="image-20221214221551550" style="zoom:50%;" />



**地址映像**

全相联映像、直接映像、组相联映像



#### 5.5.3 虚拟存储器

页式虚拟存储器

段式虚拟存储器

段页式虚拟存储器

## Chapter 6 中央处理器

### 6.1 中央处理器的功能和组成

####  6.1.1 CPU的功能

控制器的基本功能

对指令流和数据流在时间与空间上实施正确的控制。



对指令流的控制：

1.指令流出的控制

2.指令分析与执行的控制

3.指令流向的控制



对数据流的控制主要应包括

1.对数据的流入与流出的控制；

2.对数据变换、加工等操作的控制。



对于冯·诺依曼结构的计算机而言，数据流是根据指令流的操作而形成的，也就是说数据流是由指令流来驱动的。



####  6.1.2 CPU中的主要寄存器

通用寄存器



专用寄存器

PC、MAR、MDR、IR、PSWR



![image-20221214175550312](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214175550312.png)

![image-20221214175601823](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214175601823.png)

####  6.1.3 CPU的组成

![image-20221214175632287](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214175632287.png)



控制器的功能：

⑴从主存中取出一条指令，并指出下一条指令在主存中的位置。
⑵对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。
⑶指挥并控制CPU、主存和输入/输出设备之间的数据流动方向。

运算器的主要功能有：

⑴执行所有的算术运算；

⑵执行所有的逻辑运算，并进行逻辑测试。

####  6.1.4 CPU的主要技术参数

字长、内频、外频、FSB、QPI、片内Cache容量、工作电压、地址总线宽度、数据总线宽度、制造工艺

![image-20221214175945140](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214175945140.png)

![image-20221214175957481](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214175957481.png)

![image-20221214180007502](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214180007502.png)

![image-20221214180018552](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214180018552.png)

![image-20221214180028733](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214180028733.png)



### 6.2 控制器的组成和实现方法

####  6.2.1 控制器的基本组成

![image-20221214180133165](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214180133165.png)

**指令部件**

PC(程序计数器)

IR(指令寄存器)

ID(指令译码器)

地址形成部件

**时序部件**

脉冲源

启停控制逻辑

节拍信号发生器

**微操作信号发生器**

**中断控制逻辑**



####  6.2.2 控制器的硬件实现方法

组合逻辑型、存储逻辑型、组合逻辑和存储逻辑结合型(PLA控制器)

### 6.3 时序系统与控制方式

####  6.3.1 时序系统

**指令周期**

指令周期是指取指令、分析指令到执行完成该指令所需的全部时间

**机器周期**

机器周期又称为CPU周期，通常把一条指令划分为若干个机器周期，每个机器周期完成一个基本操作

Tips：在机器运行的任何时刻只能拥有一个周期状态

**节拍**

在一个机器周期内，要完成若干个微操作。这些微操作有的可以同时执行，有的需要按先后次序串行执行。因而需要把一个机器周期分为若干个相等的时间段，每一个时间段对应一个电位信号，称为节拍电位信号。
节拍的宽度取决于CPU完成一次基本操作的时间。

节拍选取方法：

统一节拍法(定长CPU周期)

分散节拍法(不定长CPU周期)

延长节拍法

**工作脉冲**

工作脉冲的宽度只占节拍电位宽度的1/n，并处于节拍的末尾。



**多级时序系统**

**三级时序系统**

小型机中常采用机器周期、节拍、工作脉冲三级时序系统。每个机器周期M中包括若干节拍，每个节拍内有一个脉冲。在机器周期间、节拍电位间、工作脉冲间既不允许有重叠交叉，也不允许有空隙，应该是一个接一个的准确连接。

**时钟周期时序系统**

在一些微型机中，时序信号中不设置节拍，而直接使用时钟周期信号。一个机器周期中含有若干个时钟周期，时钟周期的数目取决于机器周期内完成微操作的多少及相应功能部件的速度。一个机器周期的基本时钟周期数确定之后，还可以不断插入等待时钟周期。

####  6.3.2 控制方式

同步控制方式

异步控制方式

联合控制方式

####  6.3.3 指令运行的基本过程

取指令阶段

分析取数阶段

执行阶段

![image-20221214182526042](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214182526042.png)

![image-20221214182539940](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214182539940.png)

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214182657609.png" alt="image-20221214182657609" style="zoom:67%;" />

####  6.3.4 指令的微操作序列

1.加法指令ADD @R0, R1

① PCout，MARin，ALUin, Read，0→Y，
1→C0，“+”，Zin；
② Zout，PCin，Wait for MFC；
③ MDRout，IRin；
④ R0out，MARin，Read；
⑤ R1out，Yin，Wait for MFC；
⑥ MDRout， ALUin, “+” ，Zin；
⑦ Zout，MDRin；
⑧ Write 
⑨ END

2.转移指令JC A

① PCout，MARin，ALUin, Read，0→Y，1→C0
，“+”，Zin；
② Zout，PCin，Wait for MFC；
③ MDRout，IRin；
④ IF C=1 THEN PCout，Yin；IF C=0 THEN END；
⑤ Address field of IRout， ALUin, “+” ， Zin；
⑥ Zout，PCin；
⑦ END



### 6.4 微程序控制原理

微程序设计技术的实质是将程序设计技术和存储技术相结合，即用程序设计的思想方法来组织操作控制逻辑，将微操作控制信号按一定规则进行信息编码（代码化），形成控制字（微指令），再把这些微指令按时间先后排列起来，存放在一个只读存储器中。

每一条机器指令对应一段“程序”，该“程序”被存放在一个只读的控制存储器中，因为每段“程序”的执行结果是实现了一条机器指令的功能，所以我们将这些“程序”称为指令的微程序。

####  6.4.1 微程序控制的基本概念

**需要理解的概念**

微命令、微操作、微指令、微地址、微周期、微程序



**微命令和微操作**

微命令与微操作一一对应。

一条机器指令可以分解成一个微操作序列，这些微操作是计算机中最基本的、不可再分解的操作。微命令是控制计算机各部件完成某个基本微操作的命令。
微命令和微操作是一一对应的。微命令是微操作的控制信号，微操作是微命令的操作过程。

微命令有兼容性和互斥性之分，兼容性微命令是指那些可以同时产生，共同完成某一些微操作的微命令；而互斥性微命令是指在机器中不允许同时出现的微命令。兼容和互斥都是相对的，一个微命令可以和一些微命令兼容，和另一些微命令互斥。对于单独一个微命令，谈论其兼容和互斥都是没有意义的。



**微指令和微地址**

微指令是若干微命令的集合

微指令是指控制存储器中的一个单元的内容，即控制字，它是若干个微命令的 集合。放控制字的控制存储器的单元地 址就称为微地址。

一条微指令通常至少包含两大部分信息：
① 操作控制字段，又称微操作码字段，用以产生某一步操作所需的各微操作控制信号。
② 顺序控制字段，又称微地址码字段，用以控制产生下一条要执行的微指令地址。

微指令有垂直型和水平型之分，垂直型微指令接近于机器指令的格式，每条微指令只能完成一个基本操作。水平型微指令则具有良好的并行性，每条微指令可以完成较多的基本操作。



**微周期**
从控制存储器中读取一条微指令并执行相应的微命令所需的全部时间称为微周期。



**微程序**
一系列微指令的有序集合就是微程序。

一条机器指令对应于一段微程序。

![image-20221214184713982](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214184713982.png)

![image-20221214184750087](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214184750087.png)

####  6.4.2 <font color="red">微指令编码法</font>

微指令编码法指的就是操作控制字段的编码方法。各类计算机的微指令编码法不同。

一般包括三种方法:直接控制法、最短编码法、字段编码法

**直接控制法**

![image-20221214191158176](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214191158176.png)

**最短编码法**

![image-20221214191209722](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214191209722.png)

**字段编码法**

每段之内采用最短编码法，段与段之间采用直接控制法

![image-20221214191235001](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214191235001.png)

**字段直接编码法**

![image-20221214191247584](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214191247584.png)

**<font color = 'red'>字段间接编码法</font>**

字段编码法中操作控制字段的分段原
则：
① **把互斥性的微命令分在同一段内，兼容性的微命令分在不同段内。**这样不仅有助于提高信息的利用率，缩短微指令字长，而且有助于充分利用硬件所具有的并行性，加快执行的速度。

② 应与数据通路结构相适应。

③ 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。

④ **<font color = 'red'>一般每个小段还要留出一个状态，表示本字段不发出任何微命令。</font>**因此当某字段的长度为三位时，最多只能表示七个互斥的微命令，通常用000表示不操作。

![image-20221214192029716](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214192029716.png)

![image-20221214192206981](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214192206981.png)

![image-20221214192216361](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214192216361.png)

####  6.4.3 微程序控制器的组成和工作原理

####  6.4.4 微程序入口地址的形成

####  6.4.5 后继微地址的形成

####  6.4.6 微程序设计

### 6.5 控制单元的设计

####  6.5.1 简单的CPU模型

####  6.5.2 组合逻辑控制单元设计

####  6.5.3 微程序控制单元设计 

### 6.6 流水线技术

####  6.6.1 重叠控制

####  6.6.2 先行控制原理

####  6.6.3 流水工作原理

### 6.7 精简指令系统计算机

####  6.7.1 RISC的特点和优势

####  6.7.2 RISC基本技术

### 6.8 微处理器中的新技术

####  6.8.1 超标量和超流水线技术

####  6.8.2 EPIC的指令级并行处理

####  6.8.3 超线程技术

####  6.8.4 双核与多核技术

####  6.8.5 睿频加速技术

## Chapter 7 总线

不考

## Chapter 8 外部设备

### 8.1 外部设备概述

#### 8.1.1 外部设备分类

输入输出设备

辅助存储器

终端设备

过程控制设备

#### 8.1.2 外部设备的地位和作用

**地位：**

外部设备是计算机和外界联系的纽带、接口和界面。如果没有外部设备，计算机将无法工作。

**作用：**

外部设备是人机对话的通道
外部设备是完成数据媒体变换的设备
外部设备是计算机系统软件和信息的驻在地
外部设备是计算机在各领域应用的桥梁

### 8.2 磁介质存储器的性能和原理

#### 8.2.1 磁介质存储器的读写

#### 8.2.2 磁介质存储器的技术指标

**记录密度：**

记录密度是指磁介质存储器单位长度或单位面积磁层表面所能存储的二进制信息量。通常以道密度和位密度表示，也可用两者的乘积面密度来表示。

![image-20221212190142709](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221212190142709.png)

**存储容量：**

![image-20221212190223576](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221212190223576.png)

**平均存储时间：**

当磁头接到读/写命令，从原来的位置移动到指定位置，并完成读/写操作的时间叫存取时间。

对于磁盘存储器来说，存取时间主要包括4部分：

第1部分是指磁头从原先位置移动到目的磁道所需要的时间，称为定位时间或寻道时间；

第2部分是指在到达目的磁道以后，等待被访问的记录块旋转到磁头下方的等待时间，称为旋转时间或等待时间；

第3部分是信息的读写操作时间，也称为传输时间；

第4部分是磁盘控制器的开销。

![image-20221212190341612](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221212190341612.png)

时间主要在第1部分寻道时间和第2部分旋转时间上

**数据传送率：**

磁介质存储器在单位时间内向主机传送数据的位数或字节数，称为数据传送率Dr ，单位为位/秒或字节/秒。

**误码率：**

误码率是衡量磁介质存储器出错概率的参数，它等于读出的出错信息位数和读出总的信息位数之比。

#### 8.2.3 数字磁记录方式

分为直接记录方式和按位编码记录方式

##### 8.2.3.1 直接记录方式

**归零制** RZ

![image-20221212191845834](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221212191845834.png)

**不归零制 **NRZ

![image-20221212191917605](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221212191917605.png)

**不归零－1制** NRZ-1

![image-20221212191953302](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221212191953302.png)

**例子：**

![image-20221212192205850](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221212192205850.png)

##### 8.2.3.2 按位编码记录方式

**调相制** PE

![image-20221212192220597](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221212192220597.png)

**调频制** FM

![image-20221212192300165](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221212192300165.png)

**改进的调频制** MFM

![image-20221212192341245](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221212192341245.png)

Attention:假设有连续四个零，那么第一个零前面不翻转，第一个零后面、第二个零后面、第三个零后面翻转一次，第四个零后面不翻转

**改进的改进型调频制** M<sup>2</sup>FM

![image-20221212192913252](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221212192913252.png)

Attention：假设有连续四个零，那么第一个零后面翻转一次，第三个零后面翻转一次，其他地方均不翻转

**例子：**

![image-20221212192932869](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221212192932869.png)



### 8.3 磁介质存储设备

#### 8.3.1 硬盘存储器的基本结构与分类

温彻斯特盘/非温彻斯特盘

固定头/非固定头

#### 8.3.2 磁盘驱动器

磁头

磁头定位系统 ：步进/音圈

#### 8.3.3 硬盘的信息分布和磁盘地址

信息分布层次：

记录面

圆柱面

磁道

扇区

Tips:

1.当主机要存入一个较长的文件时，若一条磁道存不完，就需要存放在几条磁道上。这时主机应选择位于同一记录面上的几条磁道？还是选择同一圆柱面上的几条磁道呢？很明显，选择同一圆柱面上的磁道，则各记录面的磁头可同时定位，换道的时间仅是磁头选择电路的译码时间。所以在存入文件时，应首先将一个文件尽可能地存放在同一圆柱面中。

2.每个扇区存放一个定长信息块（如512个字节）。一条磁道划分多少扇区，每个扇区可存放多少字节，一般由操作系统决定。磁道上的扇区编号从1号开始。

磁盘地址：

磁盘地址一般表示为

驱动器号 圆柱面号 记录面号 扇区号

#### 8.3.4 硬盘存储器的技术参数

**主要性能指标：**

**硬盘容量：**非格式化容量/格式化容量

![image-20221213094746307](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213094746307.png)

**主轴转速**

**道密度**

**平均存取时间**

**缓存**

**数据传输率**

等于每一道的容量除以转一圈的时间



接口标准：

IDE、SCSI、SATA



**磁盘参数的计算**

例子：

![image-20221213094625451](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213094625451.png)

![image-20221213094640571](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213094640571.png)

#### 8.3.5 磁盘的分区域记录

![image-20221213100027809](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213100027809.png)

#### 8.3.6 硬盘的NCQ技术

**硬盘寻址的过程：**

1. 寻找目标圆柱面
2. 寻找目标盘面
3. 寻找目标扇区

![image-20221213100251442](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213100251442.png)

### 8.4 磁盘阵列

### 8.5 光盘存储器

##### **8.5.1** **光盘存储器的类型**

CD :CD-ROM、CD-R、CD-RW

DVD

BD

##### 8.5.2 光盘存储器的组成及工作原理

CLV 恒定线速度读取方式

CAV 恒定角速度读取方式

PCAV 区域恒定角速度读取方式

##### 8.5.3 **光盘驱动器**



### 8.6 键盘输入设备

#### 8.6.1 键开关和键盘类型

类型：

编码键盘/非编码键盘

#### 8.6.2 键盘扫描

逐行扫描法

行列扫描法

#### 8.6.3 PC系列键盘



### 8.7 打印输出设备

常被称为硬拷贝输出设备

#### 8.7.1 打印机概述

分类：

按印字原理分
击打式和非击打式
按印字机构分
固定字模（活字）式打印和点阵式打印
按工作方式分
串行打印机、行式打印机和页式打印机



打印机工作模式：

文本模式

图形模式



#### 8.7.2 打印机主要性能指标

分辨率 DPI

打印速度和打印幅面

接口方式

缓冲区

#### 8.7.3 针式打印机工作原理

![image-20221213102455026](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213102455026.png)

![image-20221213102515989](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213102515989.png)

![image-20221213102531829](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213102531829.png)

### 8.8 显示设备

软拷贝输出设备

#### 8.8.1 **显示器概述**

分类：

字符显示器、图形显示器、图像显示器

主动显示器件(CRT显示器、发光二极管)、被动显示器件(液晶显示器)

#### 8.8.2 CRT显示器

#### 8.8.3 字符显示器的工作原理

**VRAM**

![image-20221213104508834](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213104508834.png)

![image-20221213104723522](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213104723522.png)

![image-20221213104937722](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213104937722.png)

**VRAM地址组织**

![image-20221213104138279](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213104138279.png)

#### 8.8.4 图形显示器的工作原理

![image-20221213150817206](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213150817206.png)

![image-20221213150831625](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213150831625.png)

![image-20221213150841689](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213150841689.png)

## Chapter 9 输入输出系统

### 9.1 主机与外设的连接

#### 9.1.1 输入输出接口

主机和外设之间需要交换的信息有：

数据信息

控制信息

状态信息

联络信息

外设识别信息

#### 9.1.2 接口的功能和基本组成

##### 9.1.2.1 接口的功能

1. **实现主机和外设的通信联络控制**
2. **进行地址译码和设备选择**
3. **实现数据缓冲**
4. **数据格式的变换**
5. **传递控制命令和状态信息**

##### 9.1.2.2 接口的基本组成

接口中要分别传送数据信息、控制信息和状态信息，数据信息、控制信息和状态信息都通过数据总线来传送。

大多数计算机都把I/O设备的状态信息视为输入数据，而把控制信息看成输出数据，并在接口中分设各自相应的寄存器，赋以不同的端口地址，各种信息分时地使用数据总线传送到各自的寄存器中。



**接口与端口：**

![image-20221213151944750](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213151944750.png)



接口的类型：

![image-20221213152014689](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213152014689.png)



#### 9.1.3 外设的识别与端口寻址

外设识别是通过地址总线和接口电路中的外设识别电路来实现的，I/O端口地址就是主机与外设直接通信的地址，CPU可以通过端口发送命令、读取状态和传送数据。

**端口地址编址方式：**

I/O映射方式：也就是独立编址

存储器映射方式：也就是统一编址

![image-20221213152239964](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213152239964.png)

![image-20221213152251361](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213152251361.png)



独立编址的端口访问：

两种方式：直接寻址、间接寻址



#### 9.1.4 输入/输出信息传送控制方式

1. 程序查询方式
2. 程序中断方式
3. DMA(直接存储器存储)方式
4. I/O通道控制方式

![image-20221213152507561](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213152507561.png)

![image-20221213152519026](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213152519026.png)

### 9.2 程序查询方式及其接口

#### 9.2.1 程序查询方式

程序控制思想：

由CPU执行一段输入、输出程序来实现主存与外设之间的数据传送方式，叫做程序直接控制方式。

程序控制分类：

无条件传送/程序查询

无条件传送：

I/O接口总是准备好接收主机的输出数据，或总是准备好向主机输入的数据，因而CPU无需查询外设的工作状态，而默认外设始终处于准备就绪状态。

程序查询：

许多外设的工作状态是很难事先预知的，为了保证数据传送的正确进行，就要求CPU在程序中查询外设的工作状态，如果外设尚未准备就绪，CPU就等待，只有外设已作好准备，CPU才能执行I/O指令，这就是程序查询方式。

程序查询方式的工作流程：

1. 预置传送参数(传送参数包括存取数据的主存缓冲区首地址和传送数据的个数。)
2. 向I/O接口发命令字
3. 从I/O接口取状态字
4. 查询外设标志
5. 传送数据
6. 修改传送参数
7. 判断传送是否结束(传送个数是否为0)

#### 9.2.2 程序查询方式接口

通常接口中至少有两个寄存器，一个是**数据缓冲寄存器**，即**数据端口**，用来存放与CPU进行传送的数据信息，另一个是**供CPU查询的设备状态寄存器**，即**状态端口**，这个寄存器由多个标志位组成，其中最重要的是设备准备就绪标志。当CPU得到这位信息后就进行判断，以决定下一步是继续循环等待还是进行I/O传送，也有些计算机仅设置状态标志触发器，其作用与设备状态寄存器相同。

### 9.3 中断系统和程序中断方式

#### 9.3.1 中断的基本概念

![image-20221213153758049](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213153758049.png)

**中断的提出**

程序查询方式存在着下列明显的缺点。
① 在查询过程中，CPU长期处于踏步等待状态，使系统效率大大降低。
② CPU在一段时间内只能和一台外设交换信息，其它设备不能同时工作。
③ 不能发现和处理预先无法估计的错误和异常情况。

为了提高输入/输出能力和CPU的效率，50年代中期，中断传送方式被引进计算机系统。
现代计算机，无论是巨型机、大型机、小型机还是微型机无不具有中断能力。中断系统是计算机实现中断功能的软、硬件总称。一般在CPU中配置中断机构，在外设接口中配置中断控制器，在软件上设计相应的中断服务程序。

**程序中断和调用子程序的区别**

![image-20221213153918494](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213153918494.png)

**中断的基本类型**

自愿中断/强迫中断

程序中断/简单中断

内中断/外中断

向量中断/非向量中断

单重中断/多重中断

![image-20221213154153287](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213154153287.png)

![image-20221213154204589](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213154204589.png)

#### 9.3.2 中断请求和中断判优

中断源和中断请求信号

![image-20221213154358733](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213154358733.png)

中断请求信号的传送

![image-20221213154419589](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213154419589.png)



**中断优先级与判优方法**

![image-20221213154514928](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213154514928.png)

![image-20221213154537031](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213154537031.png)

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213154745910.png" alt="image-20221213154745910" style="zoom:50%;" />

#### 9.3.3 中断响应和中断处理

**CPU响应中断的条件**

1. CPU接收到中断请求信号
2. CPU允许中断(开中断)
3. 一条指令执行完毕

**中断隐指令**

CPU响应中断之后，经过某些操作，转去执行中断服务程序。 这些操作是由硬件直接实现的，我们把它称为中断隐指令。

中断隐指令并不是指令系统中的一条真正的指令，它没有操作码，所以中断隐指令是一种不允许、也不可能为用户使用的特殊指令。

其完成的操作主要有：

1. 保存断点
2. 暂不允许中断(关中断)
3. 引出中断服务程序

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213154938235.png" alt="image-20221213154938235" style="zoom: 67%;" />

![image-20221213155217084](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213155217084.png)

**中断周期**

![image-20221213160118987](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213160118987.png)

**中断服务程序**

![image-20221213160311757](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213160311757.png)

**向量地址分类**

![image-20221213160343307](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213160343307.png)

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213160352842.png" alt="image-20221213160352842" style="zoom:67%;" />

**中断现场的保护与恢复**

定义：

中断现场指的是发生中断时CPU的主要状态，其中最重要的是断点，另外还有一些通用寄存器的状态。

原因：

之所以需要保护
和恢复现场的原因是因为CPU要先后执行两个完全不同的程序（现行程序和中断服务程序），必须进行两种程序运行状态的转换。



现代计算机一般都先采用硬件方法来自动快速的保护和恢复部分重要的现场，其余寄存器的内容再由软件完成保护和恢复，这种方法的硬件支持是堆栈。

![image-20221213160609200](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213160609200.png)

#### 9.3.4 多重中断与中断屏蔽

**中断嵌套**

中断嵌套的层次可以有多层， 越在里层的中断越急迫，优先级越高，因此优先得到CPU的服务。

要使计算机具有多重中断的能力，首先要能保护多个断点，先发生的中断请求的断点，先保护后恢复；后发生的中断请求的断点，后保护先恢复，堆栈的先进后出特点正好满足多重中断这一先后次序的需要。在CPU进入某一中断服务程序之后，系统必须处于开中断状态，否则中断嵌套是不可能实现的。

![image-20221213160725320](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213160725320.png)

**<font color = 'red'>允许和禁止中断</font>**

允许中断还是禁止中断是用CPU中的**中断允许触发器**控制的，当中断允许触发器被置“1”，则允许中断，当中断允许触发器被置“0”，则禁止中断。



**允许中断即开中断，下列情况时应开中断：**

**⑴ 在中断服务程序执行完毕，恢复中断现场之后**

**⑵ 在多重中断的情况下，保护中断现场之后**



**禁止中断即关中断，下列情况时应关中断：**

**⑴ 当响应某一级中断请求，不再允许被其他中断请求打断时；**

**⑵ 在中断服务程序的保护和恢复现场之前。**



**中断屏蔽**

中断源发出中断请求之后，这个中断请求并不一定能真正送到CPU去，在有些情况下，可以用程序方式有选择地封锁部分中断，这就是中断屏蔽。

![image-20221213161216953](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213161216953.png)

![image-20221213161258073](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213161258073.png)



**<font color = 'red'>中断升级</font>**

![image-20221213161410482](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213161410482.png)



![image-20221213161645096](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213161645096.png)

![image-20221213161708631](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213161708631.png)

![image-20221213161553591](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213161553591.png)

#### 9.3.5 中断全过程

中断全过程是指从中断源发出中断请求开始，CPU响应这个请求，现行程序被中断，转至中断服务程序，直至中断服务程序执行完毕，CPU 再返回原来的程序继续执行的整个过程。

中断全过程分为五个阶段：

1.中断请求

2.中断判优

3.中断响应

4.中断处理

5.中断返回



其中中断处理就是执行中断服务程序

中断服务程序基本上由三部分组成

第一部分为准备部分，其基本功能是保护现场，对于非向量中断方式则需要确定中断源，最后开放中断，允许更高级的中断请求打断低级的中断服务程序。

第二部分为处理部分，即真正执行为某个中断源服务的中断服务程序。

第三部分为结尾部分，首先要关中断，以防止在恢复现场过程中被新的中断打断，接着恢复现场，然后开放中断，以便返回原来的程序后可响应其它的中断请求。

![image-20221213170409797](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213170409797.png)

### 9.4 DMA方式及其接口

#### 9.4.1 DMA方式的基本概念

**DMA方式具有下列特点：**

① 它使主存与CPU的固定联系脱钩，主存既可被CPU访问，又可被外设访问。

② 在数据块传送时，主存地址的确定，传送数据的计数等等都用硬件电路直接实现。

③ 主存中要开辟专用缓冲区，及时供给和接收外设的数据。

④ DMA传送速度快，CPU和外设并行工作，提高了系统的效率。

⑤ DMA在开始前和结束后要通过程序和中断方式进行预处理和后处理。

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213170557168.png" alt="image-20221213170557168" style="zoom:67%;" />

![image-20221213170611939](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221213170611939.png)

**DMA与中断的区别**

两者的重要区别为：

① 中断方式是程序切换，需要保护和恢复现场；而DMA方式除了开始和结尾时，不占用CPU的任何资源。

② 对中断请求的响应只能发生在每条 指令执行完毕时；而对DMA请求响应可以发生在每个机器周期结束时。

③ 中断传送过程需要CPU的干预；而DMA传送过程不需要CPU的干预，故数据传送速率非常高，适合于高速外设的成组数据传送。

④ DMA请求的优先级高于中断请求。

⑤ 中断方式具有对异常事件的处理能力；而DMA方式仅局限于完成传送信息块的I/O操作。

#### 9.4.2 DMA接口(DMA控制器)

DMA控制器功能：

⑴ 接受外设发出的DMA请求，并向CPU发出总线请求；

⑵ 当CPU响应此总线请求，发出总线响应信号后，接管对总线的控制，进入DMA操作周期；

⑶ 确定传送数据的主存单元地址及传送长度，并能自动修改主存地址计数值和传送长度计数值；

⑷ 规定数据在主存与外设之间的传送方向，发出读/写或其他控制信号，并执行数据传送的操作。

⑸ 向CPU报告DMA操作的结束。



DMA控制器的基本组成

1.主存地址计数器

2.传送长度计数器

3.数据缓冲寄存器

4.DMA请求触发器

5.控制/状态逻辑

6.<font color = 'red'>中断机构</font>

当一个数据块传送完毕，由溢出信号触发中断机构，向CPU提出中断请求，CPU将进行DMA传送的结尾处理。



DMA 控制器的引出线

1.地址总线

在DMA方式下，呈输出状态，可对主存进行地址选择；、在CPU方式下，呈输入状态，可对DMA控制器中的有关寄存器进行寻址。

2.数据总线

在DMA方式下，用它进行数据传送；

在CPU方式下，可对DMA控制器的有关寄存器进行编程。

3.控制数据传送方式的信号线

存储器读信号

存储器写信号

外设读信号

外设写信号

4.DMA控制器与外设之间的联络信号线

DMA请求信号

DMA响应信号

5.DMA控制器与CPU之间的联络信号线

总线请求

总线响应信号

DMA控制器的连接和传送

⑴ 首先由外设向DMA控制器发出请求信号DREQ。

⑵ DMA控制器向CPU发出总线请求信号HRQ。

⑶ CPU向DMA控制器发出总线响应信号HLDA，此时，DMA控制器获取了总线的控制权。

⑷ DMA控制器向外设发出DMA响应信号DACK，表示DMA控制器已控制了总线，允许外设与主存交换数据。

⑸ DMA控制器按主存地址计数器的内容发出地址信号作为主存地址的选择，同时主存地址计数器的内容加1（或减1）。

⑹ DMA控制器发出IOR信号到外设，将外设数据读入总线，同时发出MEMW信号，将数据总线的数据写入地址总线选中的主存单元。

⑺ 传送长度计数器减１。重复⑸⑹⑺步骤，直到字节计数器减到“0”为止，数据块的DMA方式传送工作宣告完成。这时，DMA控制器的HRQ降为低电平，总线控制权交还CPU。

#### 9.4.3 DMA传送方法与传送过程

**DMA传送方法**

1.CPU停止访问主存法

![image-20221214162737997](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214162737997.png)

2.存储器分时法

![image-20221214163558497](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214163558497.png)

3.周期挪用法

![image-20221214163631521](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214163631521.png)

**DMA传送过程**

1.DMA预处理

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214164241480.png" alt="image-20221214164241480" style="zoom:67%;" />

2.数据传送

<img src="C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214164302192.png" alt="image-20221214164302192" style="zoom:67%;" />

3.DMA后处理

![image-20221214164324613](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214164324613.png)



### 9.5 通道控制方式

#### 9.5.1 通道的基本概念

1.通道控制方式与DMA控制方式的区别

通道控制方式是DMA方式的进一步发展，实质上，通道也是实现外设和主存之间直接交换数据的控制器。两者的主要区别在于：

① DMA控制器是通过专门设计的硬件控制逻辑来实现对数据传送的控制；而通道则是一个具有特殊功能的处理器，它具有自己的指令和程序，通过执行一个通道程序实现对数据传送的控制，故通道具有更强的独立处理数据输入/输出的功能。

② DMA控制器通常只能控制一台或少数几台同类设备；而一个通道则可以同时控制许多台同类或不同类的设备。

2.通道的功能

① 接受CPU的I/O指令，按指令要求与指定的外设进行联系。

② 从主存取出属于该通道程序的通道指令，经译码后向设备控制器和设备发送各种命令。

③ 实施主存和外设间的数据传送。

④ 从外设获得设备的状态信息，形成并保存通道本身的状态信息，根据要求将这些状态信息送到主存的指定单元，供CPU使用。

⑤ 将外设的中断请求和通道本身的中断请求按次序及时报告CPU。

3.通道类型

(1) 字节多路通道

这种轮流服务是建立在主机的速度比外设的速度高得多的基础之上，它可以提高系统的工作效率。

![image-20221214165904385](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214165904385.png)

(2) 选择通道

![image-20221214165928452](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221214165928452.png)

(3) 数组多路通道

数组多路通道是把字节多路通道和选择通道的特点结合起来的一种通道结构。它的基本思想是：当某设备进行数据传送时，通道只为该设备服务；当设备在执行辅助操作（如磁头移动等）时，通道暂时断开与这个设备的连接，挂起该设备的通道程序，去为其他设备服务。

## Attention

#### 1. WE线不能连ROM 

ROM 是read-only memory，没有相应的引脚，不能连WE线。

#### 2. 微指令包括操作控制字段和顺序控制字段(填空题)

#### 3.  模数：

在计算机中，机器数表示数据的字长即位数是固定的。其模数的大小： 1)对于n位整数(补码)

（含一位符号位），则它的模数为2的 n次方 , 2)对于纯小数（含符号位），则它的模数总是2。

例：某一台计算机的字长为8位，则它所能表示的二进制数为00000000~11111111，共 256个，即模数为2的8次方 。

#### 4. 转移指令使用相对寻址

#### 5. 存储单元是CPU对主存可访问操作的最小存储单位

**<font color = 'red'>注意主存储器是按照字编址还是按照字节编址！否则可能爆一道大题</font>**



![image-20221219160436224](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221219160436224.png)

#### 6. 寄存器不是存储器，Cache是存储器的一种，不是寄存器

1. 寄存器是中央处理器内的组成部份。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。
2. 内存包含的范围非常广，一般分为只读存储器（ROM）、随机存储器（RAM）和高速缓存存储器（cache）。

3. 寄存器是CPU内部的元件，寄存器拥有非常高的读写速度，所以在寄存器之间的数据传送非常快。4. Cache ：即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用,这样就减少了CPU的等待时间,提高了系统的效率。Cache又分为一级Cache(L1 Cache)和二级Cache(L2 Cache)，L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上,现在也都集成在CPU内部，常见的容量有256KB或512KB L2 Cache。

总结：大致来说数据是通过内存-Cache-寄存器，Cache缓存则是为了弥补CPU与内存之间运算速度的差异而设置的的部件。
![image-20221219160918602](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221219160918602.png)

**Register**
寄存器是CPU的内部组成单元,是CPU运算时取指令和数据的地方，速度很快，寄存器可以用来暂存指令、数据和地址。在CPU中，通常有通用寄存器，如指令寄存器IR；特殊功能寄存器，如程序计数器PC、sp等。

**Cache**
缓存即就是用于暂时存放内存中的数据，若果寄存器要取内存中的一部分数据时，可直接从缓存中取到，这样可以调高速度。高速缓存是内存的部分拷贝。

CPU <--- > 寄存器<--- > 缓存<--- >内存

寄存器的工作方式很简单，只有两步：（1）找到相关的位，（2）读取这些位。

内存的工作方式就要复杂得多：

（1）找到数据的指针。（指针可能存放在寄存器内，所以这一步就已经包括寄存器的全部工作了。）

（2）将指针送往内存管理单元（MMU），由MMU将虚拟的内存地址翻译成实际的物理地址。

（3）将物理地址送往内存控制器（memory controller），由内存控制器找出该地址在哪一根内存插槽（bank）上。

（4）确定数据在哪一个内存块（chunk）上，从该块读取数据。

（5）数据先送回内存控制器，再送回CPU，然后开始使用。

内存的工作流程比寄存器多出许多步。每一步都会产生延迟，累积起来就使得内存比寄存器慢得多。

为了缓解寄存器与内存之间的巨大速度差异，硬件设计师做出了许多努力，包括在CPU内部设置缓存、优化CPU工作方式，尽量一次性从内存读取指令所要用到的全部数据等等。

**RAM-memory**
即内存，是用于存放数据的单元。其作用是用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。

**HardDisk**
硬盘

#### 7.DRAM采用地址复用技术，每增加一条地址线会地址码增加两位(行选择与列选择) 考试应该只会考SRAM？

#### 8. 指令周期 机器周期 时钟周期

指令周期是取指令、分析取数、执行指令所需的全部时间，一个指令周期有多个机器周期

机器周期又名CPU周期，包含多个时钟周期。机器周期是完成一个基本操作的时间。

时钟周期是CPU主频的倒数

#### 9. 平均等待时间、数据传输率

平均等待时间=转半圈的时间

数据传输率=道容量/转一圈的时间

#### 10.数字磁记录方式NRZ1、FM、MFM、M<sub>2</sub>FM两种画法均正确



3-11、3-12、3-16

![image-20221219141844983](C:\Users\Administrator\Desktop\github repo\Learing_note\image\计组\image-20221219141844983.png)

